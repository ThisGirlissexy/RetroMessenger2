<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- ****************************************************** -->
<!--            Standard wxWidgets header                   -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>wxWidgets: Event Handling</title>
    <meta name="author" content="wxWidgets team"/>
    <meta name="created" content="Sat Sep 6 10:17:57 2008"/>
    <meta name="keywords" content="wxWidgets"/>
    <link href="wxwidgets.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
</head>
<body>


<!--          End of wxWidgets standard header           -->
<!-- *************************************************** -->

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">wxWidgets 2.9.0: A portable C++ GUI toolkit</a>&nbsp;&raquo&nbsp;<a class="el" href="page_topics.html">Topic Overviews</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="overview_eventhandling">Event Handling </a></h1>Classes: <a class="el" href="classwx_evt_handler.html">wxEvtHandler</a>, <a class="el" href="classwx_window.html">wxWindow</a>, <a class="el" href="classwx_event.html">wxEvent</a><p>
<ul>
<li><a class="el" href="overview_eventhandling.html#overview_eventhandling_introduction">Introduction</a> </li>
<li><a class="el" href="overview_eventhandling.html#overview_eventhandling_eventtables">Event Handling with Event Tables</a> </li>
<li><a class="el" href="overview_eventhandling.html#overview_eventhandling_connect">Dynamic Event Handling</a> </li>
<li><a class="el" href="overview_eventhandling.html#overview_eventhandling_processing">How Events are Processed</a> </li>
<li><a class="el" href="overview_eventhandling.html#overview_eventhandling_prog">User Generated Events vs Programmatically Generated Events</a> </li>
<li><a class="el" href="overview_eventhandling.html#overview_eventhandling_pluggable">Pluggable Event Handlers</a> </li>
<li><a class="el" href="overview_eventhandling.html#overview_eventhandling_winid">Window Identifiers</a> </li>
<li><a class="el" href="overview_eventhandling.html#overview_eventhandling_custom">Custom Event Summary</a> </li>
<li><a class="el" href="overview_eventhandling.html#overview_eventhandling_macros">Event Handling Summary</a></li>
</ul>
<hr>
<h2><a class="anchor" name="overview_eventhandling_introduction">
Introduction</a></h2>
There are two principal ways to handle events in wxWidgets. One of them uses <em>event table</em> macros and allows you to define the connection between events and their handlers only statically, i.e. during program compilation. The other one uses <a class="el" href="classwx_evt_handler.html#78719e8b82c9f9c6e4056b3449df1943">wxEvtHandler::Connect()</a> call and can be used to connect, and disconnect, the handlers dynamically, i.e. during run-time depending on some conditions. It also allows directly connecting the events of one object to a handler method in another object while the static event tables can only handle events in the object where they are defined so using Connect() is more flexible than using the event tables. On the other hand, event tables are more succinct and centralize all event handlers connection in one place. You can either choose a single approach which you find preferable or freely combine both methods in your program in different classes or even in one and the same class, although this is probably sufficiently confusing to be a bad idea.<p>
But before you make this choice, let us discuss these two ways in some more details: in the next section we provide a short introduction to handling the events using the event tables, please see <a class="el" href="overview_eventhandling.html#overview_eventhandling_connect">Dynamic Event Handling</a> for the discussion of Connect().<h2><a class="anchor" name="overview_eventhandling_eventtables">
Event Handling with Event Tables</a></h2>
To use an <em>event table</em> you must first decide in which class you wish to handle the events. The only requirement imposed by wxWidgets is that this class must derive from <a class="el" href="classwx_evt_handler.html">wxEvtHandler</a> and so, considering that <a class="el" href="classwx_window.html">wxWindow</a> derives from it, any classes representing windows can handle events. Simple events such as menu commands are usually processed at the level of a top-level window containing the menu, so let's suppose that you need to handle some events in <code>MyFrame</code> class deriving from <a class="el" href="classwx_frame.html">wxFrame</a>.<p>
First thing to do is to define one or more <em>event handlers</em>. They are just simple (non-virtual) methods of the class which take as a parameter a reference to an object of wxEvent-derived class and have no return value (any return information is passed via the argument, which is why it is non-const). You also need to insert a macro<p>
<div class="fragment"><pre class="fragment">DECLARE_EVENT_TABLE()
</pre></div><p>
somewhere in the class declaration. It doesn't matter where does it occur but it's customary to put it at the end of it because the macro changes the access type internally and so it's safest if there is nothing that follows it. So the full class declaration might look like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyFrame : <span class="keyword">public</span> <a class="code" href="classwx_frame.html">wxFrame</a>
{
<span class="keyword">public</span>:
    MyFrame(...) : <a class="code" href="classwx_frame.html">wxFrame</a>(...) { }

    ...

protected:
    <span class="keywordtype">int</span> m_whatever;

<span class="keyword">private</span>:
    <span class="comment">// notice that as the event handlers normally are not called from outside</span>
    <span class="comment">// the class, they normally be private, in particular they don't need at</span>
    <span class="comment">// all to be public</span>
    <span class="keywordtype">void</span> OnExit(<a class="code" href="classwx_command_event.html">wxCommandEvent</a>&amp; event);
    <span class="keywordtype">void</span> OnButton1(<a class="code" href="classwx_command_event.html">wxCommandEvent</a>&amp; event);
    <span class="keywordtype">void</span> OnSize(<a class="code" href="classwx_size_event.html">wxSizeEvent</a>&amp; event);

    <span class="comment">// it's common to call the event handlers OnSomething() but there is no</span>
    <span class="comment">// obligation to it, this one is an event handler too:</span>
    <span class="keywordtype">void</span> DoTest(<a class="code" href="classwx_command_event.html">wxCommandEvent</a>&amp; event);

    DECLARE_EVENT_TABLE()
};
</pre></div><p>
Next the event table must be defined and, as any definition, it must be placed in an implementation file to tell. The event table tells wxWidgets how to map events to member functions and in our example it could look like this:<p>
<div class="fragment"><pre class="fragment">BEGIN_EVENT_TABLE(MyFrame, <a class="code" href="classwx_frame.html">wxFrame</a>)
    EVT_MENU(wxID_EXIT, MyFrame::OnExit)
    EVT_MENU(DO_TEST, MyFrame::DoTest)
    EVT_SIZE(MyFrame::OnSize)
    EVT_BUTTON(BUTTON1, MyFrame::OnButton1)
END_EVENT_TABLE()
</pre></div><p>
Notice that you must mention a method you want to use for the event handling in the event table definition, just defining it in MyFrame class is <em>not</em> enough.<p>
Let us now look at the details of this definition: the first line means that we are defining the event table for MyFrame class and that its base class is <a class="el" href="classwx_frame.html">wxFrame</a>, so events not processed by MyFrame will, by default, be handled to <a class="el" href="classwx_frame.html">wxFrame</a>. The next four lines define connections of individual events to their handlers: the first two of them map menu commands from the items with the identifiers specified as the first macro parameter to two different member functions. In the next one, <code>EVT_SIZE</code> means that any changes in the size of the frame will result in calling OnSize() method. Note that this macro doesn't need a window identifier, since normally you are only interested in the current window's size events.<p>
The EVT_BUTTON macro demonstrates that the originating event does not have to come from the window class implementing the event table -- if the event source is a button within a panel within a frame, this will still work, because event tables are searched up through the hierarchy of windows for the command events (but only command events, so you can't catch mouse move events in a child control in the parent window in the same way because <a class="el" href="classwx_mouse_event.html">wxMouseEvent</a> doesn't derive from <a class="el" href="classwx_command_event.html">wxCommandEvent</a>, see below for how you can do it). In this case, the button's event table will be searched, then the parent panel's, then the frame's.<p>
Finally, you need to implement the event handlers. As mentioned before, all event handlers take a wxEvent-derived argument whose exact class differs according to the type of event and the class of the originating window. For size events, <a class="el" href="classwx_size_event.html">wxSizeEvent</a> is used. For menu commands and most control commands (such as button presses), <a class="el" href="classwx_command_event.html">wxCommandEvent</a> is used. And when controls get more complicated, more specific wxCommandEvent-derived event classes providing additional control-specific information can be used, such as <a class="el" href="classwx_tree_event.html">wxTreeEvent</a> for events from <a class="el" href="classwx_tree_ctrl.html">wxTreeCtrl</a> windows.<p>
In the simplest possible case an event handler may not use the <code>event</code> parameter at all, e.g.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyFrame::OnExit(<a class="code" href="classwx_command_event.html">wxCommandEvent</a>&amp;)
{
    <span class="comment">// when the user selects "Exit" from the menu we should close</span>
    Close(<span class="keyword">true</span>);
}
</pre></div><p>
In other cases you may need some information carried by the <code>event</code> argument, as in:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyFrame::OnSize(<a class="code" href="classwx_size_event.html">wxSizeEvent</a>&amp; event)
{
    <a class="code" href="classwx_size.html">wxSize</a> size = <span class="keyword">event</span>.GetSize();

    ... update the frame <span class="keyword">using</span> the <span class="keyword">new</span> size ...
}
</pre></div><p>
You will find the details about the event table macros and the corresponding wxEvent-derived classes in the discussion of each control generating these events.<h2><a class="anchor" name="overview_eventhandling_connect">
Dynamic Event Handling</a></h2>
As with the event tables, you need to decide in which class do you intend to handle the events first and, also as before, this class must still derive from <a class="el" href="classwx_evt_handler.html">wxEvtHandler</a> (usually indirectly via <a class="el" href="classwx_window.html">wxWindow</a>), see the declaration of MyFrame in the previous section. However the similarities end here and both the syntax and the possibilities of this way of handling events in this way are rather different.<p>
Let us start by looking at the syntax: the first obvious difference is that you don't need to use neither <code>DECLARE_EVENT_TABLE()</code> nor <code>BEGIN_EVENT_TABLE</code> and associated macros any more. Instead, in any place in your code, but usually in the code of the class defining the handlers itself (and definitely not in the global scope as with the event tables), you should call its Connect() method like this:<p>
<div class="fragment"><pre class="fragment">MyFrame::MyFrame(...)
{
      Connect(wxID_EXIT, wxEVT_COMMAND_MENU_SELECTED,
                wxCommandEventHandler(MyFrame::OnExit));
}
</pre></div><p>
This class should be self-explanatory except for wxCommandEventHandler part: this is a macro which ensures that the method is of correct type by using static_cast in the same way as event table macros do it inside them.<p>
Now let us describe the semantic differences: <ul>
<li>
Event handlers can be connected at any moment, e.g. it's possible to do some initialization first and only connect the handlers if and when it succeeds. This can avoid the need to test that the object was properly initialized in the event handlers themselves: with Connect() they simply won't be called at all if it wasn't. <p>
</li>
<li>
As a slight extension of the above, the handlers can also be Disconnect()-ed at any time. And maybe later reconnected again. Of course, it's also possible to emulate this behaviour with the classic static (i.e. connected via event tables) handlers by using an internal flag indicating whether the handler is currently enabled and returning from it if it isn't, but using dynamically connected handlers requires less code and is also usually more clear. <p>
</li>
<li>
Also notice that you must derive a class inherited from, say, <a class="el" href="classwx_text_ctrl.html">wxTextCtrl</a> even if you don't want to modify the control behaviour at all but just want to handle some of its events. This is especially inconvenient when the control is loaded from the XRC. Connecting the event handler dynamically bypasses the need for this unwanted sub-classing. <p>
</li>
<li>
Last but very, very far from least is the possibility to connect an event of some object to a method of another object. This is impossible to do with event tables because there is no possibility to specify the object to dispatch the event to so it necessarily needs to be sent to the same object which generated the event. Not so with Connect() which has an optional <code>eventSink</code> parameter which can be used to specify the object which will handle the event. Of course, in this case the method being connected must belong to the class which is the type of the <code>eventSink</code> object! To give a quick example, people often want to catch mouse movement events happening when the mouse is in one of the frame children in the frame itself. Doing it in a naive way doesn't work: <ul>
<li>
A <code>EVT_LEAVE_WINDOW(MyFrame::OnMouseLeave)</code> line in the frame event table has no effect as mouse move (including entering and leaving) events are not propagated upwards to the parent window (at least not by default). <p>
</li>
<li>
Putting the same line in a child event table will crash during run-time because the MyFrame method will be called on a wrong object -- it's easy to convince oneself that the only object which can be used here is the pointer to the child, as wxWidgets has nothing else. But calling a frame method with the child window pointer instead of the pointer to the frame is, of course, disastrous.  </li>
</ul>
<p>
However writing <div class="fragment"><pre class="fragment">            MyFrame::MyFrame(...)
            {
              m_child-&gt;Connect(wxID_ANY, wxEVT_LEAVE_WINDOW,
                               wxMouseEventHandler(MyFrame::OnMouseLeave),
                               NULL,  <span class="comment">// unused extra data parameter</span>
                               <span class="keyword">this</span>); <span class="comment">// this indicates the object to connect to</span>
            }
</pre></div> will work exactly as expected. Note that you can get the object which generated the event -- and which is not the same as the frame -- via <a class="el" href="classwx_event.html#bdc74e95c8c2f32f2cc2bd84b88985ee">wxEvent::GetEventObject()</a> method of <code>event</code> argument passed to the event handler. </li>
<li>
</li>
</ul>
<p>
To summarize, using Connect() requires slightly more typing but is much more flexible than using static event tables so don't hesitate to use it when you need this extra power. On the other hand, event tables are still perfectly fine in simple situations where this extra flexibility is not needed.<h2><a class="anchor" name="overview_eventhandling_processing">
How Events are Processed</a></h2>
When an event is received from the windowing system, wxWidgets calls <a class="el" href="classwx_evt_handler.html#65968dd27f3aac7718f2dd6b2ddd5a08">wxEvtHandler::ProcessEvent</a> on the first event handler object belonging to the window generating the event.<p>
It may be noted that wxWidgets' event processing system implements something very close to virtual methods in normal C++, i.e. it is possible to alter the behaviour of a class by overriding its event handling functions. In many cases this works even for changing the behaviour of native controls.<p>
For example it is possible to filter out a number of key events sent by the system to a native text control by overriding <a class="el" href="classwx_text_ctrl.html">wxTextCtrl</a> and defining a handler for key events using EVT_KEY_DOWN. This would indeed prevent any key events from being sent to the native control - which might not be what is desired. In this case the event handler function has to call Skip() so as to indicate that the search for the event handler should continue.<p>
To summarize, instead of explicitly calling the base class version as you would have done with C++ virtual functions (i.e. <em>wxTextCtrl::OnChar()</em>), you should instead call <a class="el" href="classwx_event.html#98eb20b76106f9a933c2eb3ee119f66c">wxEvent::Skip</a>.<p>
In practice, this would look like this if the derived text control only accepts 'a' to 'z' and 'A' to 'Z':<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyTextCtrl::OnChar(<a class="code" href="classwx_key_event.html">wxKeyEvent</a>&amp; event)
{
    <span class="keywordflow">if</span> ( isalpha( event.KeyCode() ) )
    {
        <span class="comment">// key code is within legal range. we call event.Skip() so the</span>
        <span class="comment">// event can be processed either in the base wxWidgets class</span>
        <span class="comment">// or the native control.</span>

        <span class="keyword">event</span>.Skip();
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// illegal key hit. we don't call event.Skip() so the</span>
        <span class="comment">// event is not processed anywhere else.</span>

        <a class="code" href="group__group__funcmacro__dialog.html#g3267f33060d2ae403862427acb758bab">wxBell</a>();
    }
}
</pre></div><p>
The normal order of event table searching by ProcessEvent is as follows: <ol>
<li>
If the object is disabled (via a call to <a class="el" href="classwx_evt_handler.html#7388ae19c8657e5656471b658c320036">wxEvtHandler::SetEvtHandlerEnabled</a>) the function skips to step (6). </li>
<li>
If the object is a <a class="el" href="classwx_window.html">wxWindow</a>, <b>ProcessEvent</b> is recursively called on the window's <a class="el" href="classwx_validator.html">wxValidator</a>. If this returns <span class="literal">true</span>, the function exits. </li>
<li>
<b>SearchEventTable</b> is called for this event handler. If this fails, the base class table is tried, and so on until no more tables exist or an appropriate function was found, in which case the function exits. </li>
<li>
The search is applied down the entire chain of event handlers (usually the chain has a length of one). If this succeeds, the function exits. </li>
<li>
If the object is a <a class="el" href="classwx_window.html">wxWindow</a> and the event is set to set to propagate (in the library only <a class="el" href="classwx_command_event.html">wxCommandEvent</a> based events are set to propagate), <b>ProcessEvent</b> is recursively applied to the parent window's event handler. If this returns <span class="literal">true</span>, the function exits. </li>
<li>
Finally, <b>ProcessEvent</b> is called on the <a class="el" href="classwx_app.html">wxApp</a> object. </li>
</ol>
<b>Pay close attention to Step 5</b>. People often overlook or get confused by this powerful feature of the wxWidgets event processing system. To put it a different way, events set to propagate (see <a class="el" href="classwx_event.html#d265ef226445cb6b72a2697dd9d3b406">wxEvent::ShouldPropagate</a>) (most likely derived either directly or indirectly from <a class="el" href="classwx_command_event.html">wxCommandEvent</a>) will travel up the containment hierarchy from child to parent until the maximal propagation level is reached or an event handler is found that doesn't call <code>event.Skip()</code>.<p>
Finally, there is another additional complication (which, in fact, simplifies life of wxWidgets programmers significantly): when propagating the command events upwards to the parent window, the event propagation stops when it reaches the parent dialog, if any. This means that you don't risk to get unexpected events from the dialog controls (which might be left unprocessed by the dialog itself because it doesn't care about them) when a modal dialog is popped up. The events do propagate beyond the frames, however. The rationale for this choice is that there are only a few frames in a typical application and their parent-child relation are well understood by the programmer while it may be very difficult, if not impossible, to track down all the dialogs which may be popped up in a complex program (remember that some are created automatically by wxWidgets). If you need to specify a different behaviour for some reason, you can use wxWindow::SetExtraStyle(wxWS_EX_BLOCK_EVENTS) explicitly to prevent the events from being propagated beyond the given window or unset this flag for the dialogs which have it on by default.<p>
Typically events that deal with a window as a window (size, motion, paint, mouse, keyboard, etc.) are sent only to the window. Events that have a higher level of meaning and/or are generated by the window itself, (button click, menu select, tree expand, etc.) are command events and are sent up to the parent to see if it is interested in the event.<p>
Note that your application may wish to override ProcessEvent to redirect processing of events. This is done in the document/view framework, for example, to allow event handlers to be defined in the document or view. To test for command events (which will probably be the only events you wish to redirect), you may use <a class="el" href="classwx_event.html#d70c9cfaf0d626c1115b2d42ea047c2d">wxEvent::IsCommandEvent</a> for efficiency, instead of using the slower run-time type system.<p>
As mentioned above, only command events are recursively applied to the parents event handler in the library itself. As this quite often causes confusion for users, here is a list of system events which will NOT get sent to the parent's event handler:<p>
<ul>
<li><a class="el" href="classwx_event.html">wxEvent</a>: The event base class </li>
<li><a class="el" href="classwx_activate_event.html">wxActivateEvent</a>: A window or application activation event </li>
<li><a class="el" href="classwx_close_event.html">wxCloseEvent</a>: A close window or end session event </li>
<li><a class="el" href="classwx_erase_event.html">wxEraseEvent</a>: An erase background event </li>
<li><a class="el" href="classwx_focus_event.html">wxFocusEvent</a>: A window focus event </li>
<li><a class="el" href="classwx_key_event.html">wxKeyEvent</a>: A keypress event </li>
<li><a class="el" href="classwx_idle_event.html">wxIdleEvent</a>: An idle event </li>
<li><a class="el" href="classwx_init_dialog_event.html">wxInitDialogEvent</a>: A dialog initialisation event </li>
<li><a class="el" href="classwx_joystick_event.html">wxJoystickEvent</a>: A joystick event </li>
<li><a class="el" href="classwx_menu_event.html">wxMenuEvent</a>: A menu event </li>
<li><a class="el" href="classwx_mouse_event.html">wxMouseEvent</a>: A mouse event </li>
<li><a class="el" href="classwx_move_event.html">wxMoveEvent</a>: A move event </li>
<li><a class="el" href="classwx_paint_event.html">wxPaintEvent</a>: A paint event </li>
<li><a class="el" href="classwx_query_layout_info_event.html">wxQueryLayoutInfoEvent</a>: Used to query layout information </li>
<li><a class="el" href="classwx_set_cursor_event.html">wxSetCursorEvent</a>: Used for special cursor processing based on current mouse position </li>
<li><a class="el" href="classwx_size_event.html">wxSizeEvent</a>: A size event </li>
<li><a class="el" href="classwx_scroll_win_event.html">wxScrollWinEvent</a>: A scroll event sent by a scrolled window (not a scroll bar) </li>
<li><a class="el" href="classwx_sys_colour_changed_event.html">wxSysColourChangedEvent</a>: A system colour change event</li>
</ul>
In some cases, it might be desired by the programmer to get a certain number of system events in a parent window, for example all key events sent to, but not used by, the native controls in a dialog. In this case, a special event handler will have to be written that will override ProcessEvent() in order to pass all events (or any selection of them) to the parent window.<h2><a class="anchor" name="overview_eventhandling_prog">
User Generated Events vs Programmatically Generated Events</a></h2>
While generically wxEvents can be generated both by user actions (e.g. resize of a <a class="el" href="classwx_window.html">wxWindow</a>) and by calls to functions (e.g. <a class="el" href="classwx_window.html#7063a34cf140adfdfcaf4c5e93d6c480">wxWindow::SetSize</a>), wxWidgets controls normally send wxCommandEvent-derived events only for the user-generated events. The only <b>exceptions</b> to this rule are:<p>
<ul>
<li><a class="el" href="classwx_notebook.html#dedb8ff9f4d8072a9c786dfab89db2fb">wxNotebook::AddPage</a>: No event-free alternatives </li>
<li><a class="el" href="classwx_notebook.html#6e471f449b3e069fc2d26242b03335e3">wxNotebook::AdvanceSelection</a>: No event-free alternatives </li>
<li><a class="el" href="classwx_notebook.html#fae0fc564c4bb96d1f80ab6c68d9ead9">wxNotebook::DeletePage</a>: No event-free alternatives </li>
<li><a class="el" href="classwx_notebook.html#140d1743bc93c3aff36fe2c9f1cb2bc8">wxNotebook::SetSelection</a>: Use <a class="el" href="classwx_notebook.html#82c7c7a09de4f4ec17c92af0753235d6">wxNotebook::ChangeSelection</a> instead, as <a class="el" href="classwx_notebook.html#140d1743bc93c3aff36fe2c9f1cb2bc8">wxNotebook::SetSelection</a> is deprecated </li>
<li><a class="el" href="classwx_tree_ctrl.html#2aa115162a65bfb7e18bbc6251ccad21">wxTreeCtrl::Delete</a>: No event-free alternatives </li>
<li><a class="el" href="classwx_tree_ctrl.html#60fb31fdc2bbaf270d7a8d537622d6c5">wxTreeCtrl::DeleteAllItems</a>: No event-free alternatives </li>
<li><a class="el" href="classwx_tree_ctrl.html#d59064a4c2061aa4460bcea70318b57b">wxTreeCtrl::EditLabel</a>: No event-free alternatives </li>
<li>All <a class="el" href="classwx_text_ctrl.html">wxTextCtrl</a> methods</li>
</ul>
<a class="el" href="classwx_text_ctrl.html#989fe016bdf4202a6d533294913a2dbb">wxTextCtrl::ChangeValue</a> can be used instead of <a class="el" href="classwx_text_ctrl.html#d44d3595e5adf219c996b74159348db7">wxTextCtrl::SetValue</a> but the other functions, such as <a class="el" href="classwx_text_ctrl.html#d53f8089b06f68e229e6dfe223eb7115">wxTextCtrl::Replace</a> or <a class="el" href="classwx_text_ctrl.html#9badaa463c20a5e1469e59b972481bef">wxTextCtrl::WriteText</a> don't have event-free equivalents.<h2><a class="anchor" name="overview_eventhandling_pluggable">
Pluggable Event Handlers</a></h2>
In fact, you don't have to derive a new class from a window class if you don't want to. You can derive a new class from <a class="el" href="classwx_evt_handler.html">wxEvtHandler</a> instead, defining the appropriate event table, and then call <a class="el" href="classwx_window.html#f6c84b7679183b377ba27a52a2f708b4">wxWindow::SetEventHandler</a> (or, preferably, <a class="el" href="classwx_window.html#398c11ab9af7956067a964f560d1978c">wxWindow::PushEventHandler</a>) to make this event handler the object that responds to events. This way, you can avoid a lot of class derivation, and use instances of the same event handler class (but different objects as the same event handler object shouldn't be used more than once) to handle events from instances of different widget classes.<p>
If you ever have to call a window's event handler manually, use the GetEventHandler function to retrieve the window's event handler and use that to call the member function. By default, GetEventHandler returns a pointer to the window itself unless an application has redirected event handling using SetEventHandler or PushEventHandler.<p>
One use of PushEventHandler is to temporarily or permanently change the behaviour of the GUI. For example, you might want to invoke a dialog editor in your application that changes aspects of dialog boxes. You can grab all the input for an existing dialog box, and edit it 'in situ', before restoring its behaviour to normal. So even if the application has derived new classes to customize behaviour, your utility can indulge in a spot of body-snatching. It could be a useful technique for on-line tutorials, too, where you take a user through a serious of steps and don't want them to diverge from the lesson. Here, you can examine the events coming from buttons and windows, and if acceptable, pass them through to the original event handler. Use PushEventHandler/PopEventHandler to form a chain of event handlers, where each handler processes a different range of events independently from the other handlers.<h2><a class="anchor" name="overview_eventhandling_winid">
Window Identifiers</a></h2>
Window identifiers are integers, and are used to uniquely determine window identity in the event system (though you can use it for other purposes). In fact, identifiers do not need to be unique across your entire application just so long as they are unique within a particular context you're interested in, such as a frame and its children. You may use the <code>wxID_OK</code> identifier, for example, on any number of dialogs so long as you don't have several within the same dialog.<p>
If you pass <code>wxID_ANY</code> to a window constructor, an identifier will be generated for you automatically by wxWidgets. This is useful when you don't care about the exact identifier either because you're not going to process the events from the control being created at all or because you process the events from all controls in one place (in which case you should specify <code>wxID_ANY</code> in the event table or <a class="el" href="classwx_evt_handler.html#78719e8b82c9f9c6e4056b3449df1943">wxEvtHandler::Connect</a> call as well. The automatically generated identifiers are always negative and so will never conflict with the user-specified identifiers which must be always positive.<p>
See <a class="el" href="page_stdevtid.html">Standard event identifiers</a> for the list of standard identifiers available. You can use wxID_HIGHEST to determine the number above which it is safe to define your own identifiers. Or, you can use identifiers below wxID_LOWEST. Finally, you can allocate identifiers dynamically using <a class="el" href="utils_8h.html#ef162e1ba5d17a839b2f7912424bc822">wxNewId()</a> function to. If you use <a class="el" href="utils_8h.html#ef162e1ba5d17a839b2f7912424bc822">wxNewId()</a> consistently in your application, you can be sure that the your identifiers don't conflict accidentally.<h2><a class="anchor" name="overview_eventhandling_custom">
Custom Event Summary</a></h2>
<h3><a class="anchor" name="overview_eventhandling_custom_general">
General approach</a></h3>
Since version 2.2.x of wxWidgets, each event type is identified by ID which is given to the event type <em>at</em> runtime which makes it possible to add new event types to the library or application without risking ID clashes (two different event types mistakingly getting the same event ID). This event type ID is stored in a struct of type <b>const</b> wxEventType.<p>
In order to define a new event type, there are principally two choices. One is to define a entirely new event class (typically deriving from <a class="el" href="classwx_event.html">wxEvent</a> or <a class="el" href="classwx_command_event.html">wxCommandEvent</a>.<p>
The other is to use the existing event classes and give them an new event type. You'll have to define and declare a new event type using either way, and this is done using the following macros:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// in the header of the source file</span>
BEGIN_DECLARE_EVENT_TYPES()
DECLARE_EVENT_TYPE(name, value)
END_DECLARE_EVENT_TYPES()

<span class="comment">// in the implementation</span>
DEFINE_EVENT_TYPE(name)
</pre></div><p>
You can ignore the <em>value</em> parameter of the DECLARE_EVENT_TYPE macro since it is used only for backwards compatibility with wxWidgets 2.0.x based applications where you have to give the event type ID an explicit value. See also the <a class="el" href="page_samples.html#page_samples_event">Event Sample</a> for an example of code defining and working with the custom event types.<h3><a class="anchor" name="overview_eventhandling_custom_existing">
Using Existing Event Classes</a></h3>
If you just want to use a <a class="el" href="classwx_command_event.html">wxCommandEvent</a> with a new event type, you can then use one of the generic event table macros listed below, without having to define a new macro yourself. This also has the advantage that you won't have to define a new <a class="el" href="classwx_event.html#26878097a702e8d0368da150125d4158">wxEvent::Clone()</a> method for posting events between threads etc. This could look like this in your code:<p>
<div class="fragment"><pre class="fragment">DECLARE_EVENT_TYPE(wxEVT_MY_EVENT, -1)
DEFINE_EVENT_TYPE(wxEVT_MY_EVENT)

<span class="comment">// user code intercepting the event</span>

BEGIN_EVENT_TABLE(MyFrame, <a class="code" href="classwx_frame.html">wxFrame</a>)
EVT_MENU    (wxID_EXIT, MyFrame::OnExit)
<span class="comment">// ....</span>
EVT_COMMAND  (ID_MY_WINDOW, wxEVT_MY_EVENT, MyFrame::OnMyEvent)
END_EVENT_TABLE()

<span class="keywordtype">void</span> MyFrame::OnMyEvent( <a class="code" href="classwx_command_event.html">wxCommandEvent</a>  )
{
    <span class="comment">// do something</span>
    <a class="code" href="classwx_string.html">wxString</a> text = <span class="keyword">event</span>.GetText();
}


<span class="comment">// user code sending the event</span>

<span class="keywordtype">void</span> MyWindow::SendEvent()
{
    wxCommandEvent event( wxEVT_MY_EVENT, GetId() );
    <span class="keyword">event</span>.SetEventObject( <span class="keyword">this</span> );
    <span class="comment">// Give it some contents</span>
    <span class="keyword">event</span>.SetText( <a class="code" href="group__group__funcmacro__string.html#g437ea6ba615b75dac8603e96ec864160">wxT</a>(<span class="stringliteral">"Hallo"</span>) );
    <span class="comment">// Send it</span>
    GetEventHandler()-&gt;ProcessEvent( event );
}
</pre></div><h3><a class="anchor" name="overview_eventhandling_custom_generic">
Generic Event Table Macros</a></h3>
<table class="doctable" border="1" cellspacing="0" cellpadding="3">
<tr>
<td>EVT_CUSTOM(event, id, func) </td><td>Allows you to add a custom event table entry by specifying the event identifier (such as wxEVT_SIZE), the window identifier, and a member function to call. </td></tr>
<tr>
<td>EVT_CUSTOM_RANGE(event, id1, id2, func) </td><td>The same as EVT_CUSTOM, but responds to a range of window identifiers. </td></tr>
<tr>
<td>EVT_COMMAND(id, event, func) </td><td>The same as EVT_CUSTOM, but expects a member function with a <a class="el" href="classwx_command_event.html">wxCommandEvent</a> argument. </td></tr>
<tr>
<td>EVT_COMMAND_RANGE(id1, id2, event, func) </td><td>The same as EVT_CUSTOM_RANGE, but expects a member function with a <a class="el" href="classwx_command_event.html">wxCommandEvent</a> argument. </td></tr>
<tr>
<td>EVT_NOTIFY(event, id, func) </td><td>The same as EVT_CUSTOM, but expects a member function with a <a class="el" href="classwx_notify_event.html">wxNotifyEvent</a> argument. </td></tr>
<tr>
<td>EVT_NOTIFY_RANGE(event, id1, id2, func) </td><td>The same as EVT_CUSTOM_RANGE, but expects a member function with a <a class="el" href="classwx_notify_event.html">wxNotifyEvent</a> argument. </td></tr>
</table>
<h3><a class="anchor" name="overview_eventhandling_custom_ownclass">
Defining Your Own Event Class</a></h3>
Under certain circumstances, it will be required to define your own event class e.g. for sending more complex data from one place to another. Apart from defining your event class, you will also need to define your own event table macro (which is quite long). Watch out to put in enough casts to the inherited event function. Here is an example:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// code defining event</span>

<span class="keyword">class </span>wxPlotEvent: <span class="keyword">public</span> <a class="code" href="classwx_notify_event.html">wxNotifyEvent</a>
{
<span class="keyword">public</span>:
    wxPlotEvent( wxEventType commandType = wxEVT_NULL, <span class="keywordtype">int</span> <span class="keywordtype">id</span> = 0 );

    <span class="comment">// accessors</span>
    wxPlotCurve *GetCurve()
        { <span class="keywordflow">return</span> m_curve; }

    <span class="comment">// required for sending with wxPostEvent()</span>
    <span class="keyword">virtual</span> <a class="code" href="classwx_event.html">wxEvent</a> *Clone() <span class="keyword">const</span>;

<span class="keyword">private</span>:
    wxPlotCurve   *m_curve;
};

DECLARE_EVENT_TYPE( wxEVT_PLOT_ACTION, -1 )

typedef <span class="keywordtype">void</span> (<a class="code" href="classwx_evt_handler.html">wxEvtHandler</a>::*wxPlotEventFunction)(wxPlotEvent&amp;);

<span class="preprocessor">#define EVT_PLOT(id, fn) \</span>
<span class="preprocessor">    DECLARE_EVENT_TABLE_ENTRY( wxEVT_PLOT_ACTION, id, -1, \</span>
<span class="preprocessor">    (wxObjectEventFunction) (wxEventFunction) (wxCommandEventFunction) (wxNotifyEventFunction) \</span>
<span class="preprocessor">    wxStaticCastEvent( wxPlotEventFunction, &amp;fn ), (wxObject *) NULL ),</span>
<span class="preprocessor"></span>

<span class="comment">// code implementing the event type and the event class</span>

DEFINE_EVENT_TYPE( wxEVT_PLOT_ACTION )

wxPlotEvent::wxPlotEvent( ...


<span class="comment">// user code intercepting the event</span>

BEGIN_EVENT_TABLE(MyFrame, <a class="code" href="classwx_frame.html">wxFrame</a>)
EVT_PLOT  (ID_MY_WINDOW, MyFrame::OnPlot)
END_EVENT_TABLE()

<span class="keywordtype">void</span> MyFrame::OnPlot( wxPlotEvent &amp;event )
{
    wxPlotCurve *curve = <span class="keyword">event</span>.GetCurve();
}


<span class="comment">// user code sending the event</span>

<span class="keywordtype">void</span> MyWindow::SendEvent()
{
    wxPlotEvent event( wxEVT_PLOT_ACTION, GetId() );
    <span class="keyword">event</span>.SetEventObject( <span class="keyword">this</span> );
    <span class="keyword">event</span>.SetCurve( m_curve );
    GetEventHandler()-&gt;ProcessEvent( event );
}
</pre></div><h2><a class="anchor" name="overview_eventhandling_macros">
Event Handling Summary</a></h2>
For the full list of event classes, please see the <a class="el" href="group__group__class__events.html">event classes group page</a>.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>for all controls state clearly when calling a member function results in an event being generated and when it doesn't (possibly updating also the 'Events generated by the user vs programmatically generated events' paragraph of the 'Event handling overview' with the list of the functions which break that rule).</dd></dl>
</div>
<!-- ******************************************************* -->
<!--             Standard wxWidgets footer                   -->

<!-- NOTE: <br/> must go inside <p> but <hr/> must go outside -->
<p><br/></p><hr/>

<table width="100%" border="0">
<tr>
    <td align="left">
        <a href="http://www.wxwidgets.org/" style="margin-left: 0px">
            <img src="powered-by-wxwidgets.png" alt="wxWidgets logo" border="0"/>
        </a>
    </td>
    <td valign="middle" align="center"><p class="footer">Page generated <tt>Sat Sep 6 10:17:57 2008</tt> by <a href="http://www.doxygen.org/">Doxygen</a> 1.5.6</p></td>
    <td valign="middle" align="right"><p>[ <a href="wsdindex.html#top" class="top">top</a> ]</p></td>
</tr>
</table>

<script src="wxwidgets.js" type="text/javascript"></script>

<script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
    var pageTracker = _gat._getTracker("UA-794025-2");
    pageTracker._initData();
    pageTracker._trackPageview();
</script>

</body>
</html>

<!-- ***************************************************** -->
<!--         End of wxWidgets standard footer              -->
