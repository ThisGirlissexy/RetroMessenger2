<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- ****************************************************** -->
<!--            Standard wxWidgets header                   -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>wxWidgets: Unicode Support in wxWidgets</title>
    <meta name="author" content="wxWidgets team"/>
    <meta name="created" content="Sat Sep 6 10:17:57 2008"/>
    <meta name="keywords" content="wxWidgets"/>
    <link href="wxwidgets.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
</head>
<body>


<!--          End of wxWidgets standard header           -->
<!-- *************************************************** -->

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">wxWidgets 2.9.0: A portable C++ GUI toolkit</a>&nbsp;&raquo&nbsp;<a class="el" href="page_topics.html">Topic Overviews</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="overview_unicode">Unicode Support in wxWidgets </a></h1>This section describes how does wxWidgets support Unicode and how can it affect your programs.<p>
Notice that Unicode support has changed radically in wxWidgets 3.0 and a lot of existing material pertaining to the previous versions of the library is not correct any more. Please see <a class="el" href="overview_changes_since28.html#overview_changes_unicode">Unicode-related Changes</a> for the details of these changes.<p>
You can skip the first two sections if you're already familiar with Unicode and wish to jump directly in the details of its support in the library: <ul>
<li><a class="el" href="overview_unicode.html#overview_unicode_what">What is Unicode?</a> </li>
<li><a class="el" href="overview_unicode.html#overview_unicode_encodings">Unicode Representations</a> </li>
<li><a class="el" href="overview_unicode.html#overview_unicode_supportin">Unicode Support in wxWidgets</a> </li>
<li><a class="el" href="overview_unicode.html#overview_unicode_pitfalls">Potential Unicode Pitfalls</a> </li>
<li><a class="el" href="overview_unicode.html#overview_unicode_supportout">Unicode and the Outside World</a> </li>
<li><a class="el" href="overview_unicode.html#overview_unicode_settings">Unicode Related Compilation Settings</a></li>
</ul>
<hr>
<h2><a class="anchor" name="overview_unicode_what">
What is Unicode?</a></h2>
Unicode is a standard for character encoding which addresses the shortcomings of the previous, 8 bit standards, by using at least 16 (and possibly 32) bits for encoding each character. This allows to have at least 65536 characters (in what is called the BMP, or basic multilingual plane) and possible 2^32 of them instead of the usual 256 and is sufficient to encode all of the world languages at once. More details about Unicode may be found at <a href="http://www.unicode.org/.">http://www.unicode.org/.</a><p>
From a practical point of view, using Unicode is almost a requirement when writing applications for international audience. Moreover, any application reading files which it didn't produce or receiving data from the network from other services should be ready to deal with Unicode.<h2><a class="anchor" name="overview_unicode_encodings">
Unicode Representations</a></h2>
Unicode provides a unique code to identify every character, however in practice these codes are not always used directly but encoded using one of the standard UTF or Unicode Transformation Formats which are algorithms mapping the Unicode codes to byte code sequences. The simplest of them is UTF-32 which simply maps the Unicode code to a 4 byte sequence representing this 32 bit number (although this is still not completely trivial as the mapping is different for little and big-endian architectures). UTF-32 is commonly used under Unix systems for internal representation of Unicode strings. Another very widespread standard is UTF-16 which is used by Microsoft Windows: it encodes the first (approximately) 64 thousands of Unicode characters using only 2 bytes and uses a pair of 16-bit codes to encode the characters beyond this. Finally, the most widespread encoding used for the external Unicode storage (e.g. files and network protocols) is UTF-8 which is byte-oriented and so avoids the endianness ambiguities of UTF-16 and UTF-32. However UTF-8 uses a variable number of bytes for representing Unicode characters which makes it less efficient than UTF-32 for internal representation.<p>
From the C/C++ programmer perspective the situation is further complicated by the fact that the standard type <code>wchar_t</code> which is used to represent the Unicode ("wide") strings in C/C++ doesn't have the same size on all platforms. It is 4 bytes under Unix systems, corresponding to the tradition of using UTF-32, but only 2 bytes under Windows which is required by compatibility with the OS which uses UTF-16.<h2><a class="anchor" name="overview_unicode_supportin">
Unicode Support in wxWidgets</a></h2>
Since wxWidgets 3.0 Unicode support is always enabled and building the library without it is not recommended any longer and will cease to be supported in the near future. This means that internally only Unicode strings are used and that, under Microsoft Windows, Unicode system API is used which means that wxWidgets programs require the Microsoft Layer for Unicode to run on Windows 95/98/ME.<p>
However, unlike Unicode build mode in the previous versions of wxWidgets, this support is mostly transparent: you can still continue to work with the narrow (i.e. <code>char*</code>) strings even if wide (i.e. <code>wchar_t*</code>) strings are also supported. Any wxWidgets function accepts arguments of either type as both kinds of strings are implicitly converted to <a class="el" href="classwx_string.html">wxString</a>, so both <div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__dialog.html#gf8a6b7e1e34eae82d3d75e3721298b26">wxMessageBox</a>(<span class="stringliteral">"Hello, world!"</span>);
</pre></div> and somewhat less usual <div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__dialog.html#gf8a6b7e1e34eae82d3d75e3721298b26">wxMessageBox</a>(L<span class="stringliteral">"Salut \u00e0 toi!"</span>); <span class="comment">// 00E0 is "Latin Small Letter a with Grave"</span>
</pre></div> work as expected.<p>
Notice that the narrow strings used with wxWidgets are <em>always</em> assumed to be in the current locale encoding, so writing <div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__dialog.html#gf8a6b7e1e34eae82d3d75e3721298b26">wxMessageBox</a>(<span class="stringliteral">"Salut Ã  toi!"</span>);
</pre></div> wouldn't work if the encoding used on the user system is incompatible with ISO-8859-1 (or even if the sources were compiled under different locale in the case of gcc). In particular, the most common encoding used under modern Unix systems is UTF-8 and as the string above is not a valid UTF-8 byte sequence, nothing would be displayed at all in this case. Thus it is important to never use 8 bit characters directly in the program source but use wide strings or, alternatively, write <div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__dialog.html#gf8a6b7e1e34eae82d3d75e3721298b26">wxMessageBox</a>(<a class="code" href="classwx_string.html#2ddc1b7c8e1eb9adbf5874dead5b180b">wxString::FromUTF8</a>(<span class="stringliteral">"Salut \xc3\xa0 toi!"</span>));
</pre></div><p>
In a similar way, <a class="el" href="classwx_string.html">wxString</a> provides access to its contents as either wchar_t or char character buffer. Of course, the latter only works if the string contains data representable in the current locale encoding. This will always be the case if the string had been initially constructed from a narrow string or if it contains only 7-bit ASCII data but otherwise this conversion is not guaranteed to succeed. And as with <code>FromUTF8()</code> example above, you can always use <code>ToUTF8()</code> to retrieve the string contents in UTF-8 encoding -- this, unlike converting to <code>char*</code> using the current locale, never fails<p>
To summarize, Unicode support in wxWidgets is mostly transparent for the application and if you use <a class="el" href="classwx_string.html">wxString</a> objects for storing all the character data in your program there is really nothing special to do. However you should be aware of the potential problems covered by the following section.<h2><a class="anchor" name="overview_unicode_pitfalls">
Potential Unicode Pitfalls</a></h2>
The problems can be separated into three broad classes:<h3><a class="anchor" name="overview_unicode_compilation_errors">
Unicode-Related Compilation Errors</a></h3>
Because of the need to support implicit conversions to both <code>char</code> and <code>wchar_t</code>, <a class="el" href="classwx_string.html">wxString</a> implementation is rather involved and many of its operators don't return the types which they could be naively expected to return. For example, the <code>operator</code>[] doesn't return neither a <code>char</code> nor a <code>wchar_t</code> but an object of a helper class wxUniChar or wxUniCharRef which is implicitly convertible to either. Usually you don't need to worry about this as the conversions do their work behind the scenes however in some cases it doesn't work. Here are some examples, using a <a class="el" href="classwx_string.html">wxString</a> object <code>s</code> and some integer <code>n:</code> <p>
<ul>
<li>Writing <div class="fragment"><pre class="fragment"> <span class="keywordflow">switch</span> ( s[n] ) 
</pre></div> doesn't work because the argument of the switch statement must an integer expression so you need to replace <code>s</code>[n] with <div class="fragment"><pre class="fragment"> s[n].GetValue() 
</pre></div>. You may also force the conversion to char or wchar_t by using an explicit cast but beware that converting the value to char uses the conversion to current locale and may return 0 if it fails. Finally notice that writing <div class="fragment"><pre class="fragment"> (wxChar)s[n] 
</pre></div> works both with wxWidgets 3.0 and previous library versions and so should be used for writing code which should be compatible with both 2.8 and 3.0.</li></ul>
<p>
<ul>
<li>Similarly, <div class="fragment"><pre class="fragment"> &amp;s[n] 
</pre></div> doesn't yield a pointer to char so you may not pass it to functions expecting <code>char*</code> or <code>wchar_t*</code>. Consider using string iterators instead if possible or replace this expression with <div class="fragment"><pre class="fragment"> s.<a class="code" href="classwx_string.html#7b03261d7b716ef7d11c8c304971c457">c_str</a>() + n 
</pre></div> otherwise.</li></ul>
<p>
Another class of problems is related to the fact that the value returned by <code>c_str()</code> itself is also not just a pointer to a buffer but a value of helper class wxCStrData which is implicitly convertible to both narrow and wide strings. Again, this mostly will be unnoticeable but can result in some problems:<p>
<ul>
<li>You shouldn't pass <code>c_str()</code> result to vararg functions such as standard <code>printf()</code>. Some compilers (notably g++) warn about this but even if they don't, this <div class="fragment"><pre class="fragment"> printf(<span class="stringliteral">"Hello, %s"</span>, s.<a class="code" href="classwx_string.html#7b03261d7b716ef7d11c8c304971c457">c_str</a>()) 
</pre></div> is not going to work. It can be corrected in one of the following ways:</li></ul>
<p>
<ul>
<li>Preferred: <div class="fragment"><pre class="fragment"> wxPrintf(<span class="stringliteral">"Hello, %s"</span>, s) 
</pre></div> (notice the absence of <code>c_str()</code>, it is not needed at all with wxWidgets functions)</li><li>Compatible with wxWidgets 2.8: <div class="fragment"><pre class="fragment"> wxPrintf(<span class="stringliteral">"Hello, %s"</span>, s.<a class="code" href="classwx_string.html#7b03261d7b716ef7d11c8c304971c457">c_str</a>()) 
</pre></div></li><li>Using an explicit conversion to narrow, multibyte, string: <div class="fragment"><pre class="fragment"> printf(<span class="stringliteral">"Hello, %s"</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span> *)s.<a class="code" href="classwx_string.html#dcfd12e6d0765b1d74bccc3d63d02e98">mb_str</a>()) 
</pre></div></li><li>Using a cast to force the issue (listed only for completeness): <div class="fragment"><pre class="fragment"> printf(<span class="stringliteral">"Hello, %s"</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span> *)s.<a class="code" href="classwx_string.html#7b03261d7b716ef7d11c8c304971c457">c_str</a>()) 
</pre></div></li></ul>
<p>
<ul>
<li>The result of <code>c_str()</code> can not be cast to <code>char*</code> but only to <code>const</code> <code><code>char*</code>.</code> Of course, modifying the string via the pointer returned by this method has never been possible but unfortunately it was occasionally useful to use a <code>const_cast</code> here to pass the value to const-incorrect functions. This can be done either using new <a class="el" href="classwx_string.html#edcaea87fc347a940263a533bd56846f">wxString::char_str()</a> (and matching wchar_str()) method or by writing a double cast: <div class="fragment"><pre class="fragment"> (<span class="keywordtype">char</span> *)(<span class="keyword">const</span> <span class="keywordtype">char</span> *)s.<a class="code" href="classwx_string.html#7b03261d7b716ef7d11c8c304971c457">c_str</a>() 
</pre></div></li></ul>
<p>
<ul>
<li>One of the unfortunate consequences of the possibility to pass <a class="el" href="classwx_string.html">wxString</a> to <code>wxPrintf()</code> without using <code>c_str()</code> is that it is now impossible to pass the elements of unnamed enumerations to <code>wxPrintf()</code> and other similar vararg functions, i.e. <div class="fragment"><pre class="fragment">        <span class="keyword">enum</span> { Red, Green, Blue };
        wxPrintf(<span class="stringliteral">"Red is %d"</span>, Red);
</pre></div> doesn't compile. The easiest workaround is to give a name to the enum.</li></ul>
<p>
Other unexpected compilation errors may arise but they should happen even more rarely than the above-mentioned ones and the solution should usually be quite simple: just use the explicit methods of wxUniChar and wxCStrData classes instead of relying on their implicit conversions if the compiler can't choose among them.<h3><a class="anchor" name="overview_unicode_data_loss">
Data Loss due To Unicode Conversion Errors</a></h3>
<a class="el" href="classwx_string.html">wxString</a> API provides implicit conversion of the internal Unicode string contents to narrow, char strings. This can be very convenient and is absolutely necessary for backwards compatibility with the existing code using wxWidgets however it is a rather dangerous operation as it can easily give unexpected results if the string contents isn't convertible to the current locale.<p>
To be precise, the conversion will always succeed if the string was created from a narrow string initially. It will also succeed if the current encoding is UTF-8 as all Unicode strings are representable in this encoding. However initializing the string using FromUTF8() method and then accessing it as a char string via its c_str() method is a recipe for disaster as the program may work perfectly well during testing on Unix systems using UTF-8 locale but completely fail under Windows where UTF-8 locales are never used because c_str() would return an empty string.<p>
The simplest way to ensure that this doesn't happen is to avoid conversions to <code>char*</code> completely by using <a class="el" href="classwx_string.html">wxString</a> throughout your program. However if the program never manipulates 8 bit strings internally, using <code>char*</code> pointers is safe as well. So the existing code needs to be reviewed when upgrading to wxWidgets 3.0 and the new code should be used with this in mind and ideally avoiding implicit conversions to <code>char*</code>.<h3><a class="anchor" name="overview_unicode_performance">
Unicode Performance Implications</a></h3>
Under Unix systems <a class="el" href="classwx_string.html">wxString</a> class uses variable-width UTF-8 encoding for internal representation and this implies that it can't guarantee constant-time access to N-th element of the string any longer as to find the position of this character in the string we have to examine all the preceding ones. Usually this doesn't matter much because most algorithms used on the strings examine them sequentially anyhow and because <a class="el" href="classwx_string.html">wxString</a> implements a cache for iterating over the string by index but it can have serious consequences for algorithms using random access to string elements as they typically acquire O(N^2) time complexity instead of O(N) where N is the length of the string.<p>
Even despite caching the index, indexed access should be replaced with sequential access using string iterators. For example a typical loop: <div class="fragment"><pre class="fragment"><a class="code" href="classwx_string.html">wxString</a> s(<span class="stringliteral">"hello"</span>);
<span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> i = 0; i &lt; s.<a class="code" href="classwx_string.html#f63f200410b56436a830550905e20539">length</a>(); i++ )
{
    <span class="keywordtype">wchar_t</span> ch = s[i];
    
    <span class="comment">// do something with it</span>
}
</pre></div> should be rewritten as <div class="fragment"><pre class="fragment"><a class="code" href="classwx_string.html">wxString</a> s(<span class="stringliteral">"hello"</span>);
<span class="keywordflow">for</span> ( wxString::const_iterator i = s.<a class="code" href="classwx_string.html#d59ca2dd208720b3cce07d90bcb90093">begin</a>(); i != s.<a class="code" href="classwx_string.html#6a0f235fff88df5e6b16b5f0e1e719cc">end</a>(); ++i )
{
    <span class="keywordtype">wchar_t</span> ch = *i
    
    <span class="comment">// do something with it</span>
}
</pre></div><p>
Another, similar, alternative is to use pointer arithmetic: <div class="fragment"><pre class="fragment"><a class="code" href="classwx_string.html">wxString</a> s(<span class="stringliteral">"hello"</span>);
<span class="keywordflow">for</span> ( <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *p = s.<a class="code" href="classwx_string.html#6cd4782263a3ed4064eca915eb6e27e6">wc_str</a>(); *p; p++ )
{
    <span class="keywordtype">wchar_t</span> ch = *i

    <span class="comment">// do something with it</span>
}
</pre></div> however this doesn't work correctly for strings with embedded <code>NUL</code> characters and the use of iterators is generally preferred as they provide some run-time checks (at least in debug build) unlike the raw pointers. But if you do use them, it is better to use wchar_t pointers rather than char ones to avoid the data loss problems due to conversion as discussed in the previous section.<h2><a class="anchor" name="overview_unicode_supportout">
Unicode and the Outside World</a></h2>
Even though wxWidgets always uses Unicode internally, not all the other libraries and programs do and even those that do use Unicode may use a different encoding of it. So you need to be able to convert the data to various representations and the <a class="el" href="classwx_string.html">wxString</a> methods ToAscii(), ToUTF8() (or its synonym utf8_str()), mb_str(), c_str() and wc_str() can be used for this. The first of them should be only used for the string containing 7-bit ASCII characters only, anything else will be replaced by some substitution character. mb_str() converts the string to the encoding used by the current locale and so can return an empty string if the string contains characters not representable in it as explained in <a class="el" href="overview_unicode.html#overview_unicode_data_loss">Data Loss due To Unicode Conversion Errors</a>. The same applies to c_str() if its result is used as a narrow string. Finally, ToUTF8() and wc_str() functions never fail and always return a pointer to char string containing the UTF-8 representation of the string or wchar_t string.<p>
<a class="el" href="classwx_string.html">wxString</a> also provides two convenience functions: From8BitData() and To8BitData(). They can be used to create <a class="el" href="classwx_string.html">wxString</a> from arbitrary binary data without supposing that it is in current locale encoding, and then get it back, again, without any conversion or, rather, undoing the conversion used by From8BitData(). Because of this you should only use From8BitData() for the strings created using To8BitData(). Also notice that in spite of the availability of these functions, <a class="el" href="classwx_string.html">wxString</a> is not the ideal class for storing arbitrary binary data as they can take up to 4 times more space than needed (when using <code>wchar_t</code> internal representation on the systems where size of wide characters is 4 bytes) and you should consider using <a class="el" href="classwx_memory_buffer.html">wxMemoryBuffer</a> instead.<p>
Final word of caution: most of these functions may return either directly the pointer to internal string buffer or a temporary wxCharBuffer or wxWCharBuffer object. Such objects are implicitly convertible to char and wchar_t pointers, respectively, and so the result of, for example, ToUTF8() can always be passed directly to a function taking <code>const</code> <code>char*</code>. However code such as <div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">char</span> *p = s.<a class="code" href="classwx_string.html#20ab14e8e240ef042bacda5a99e520d7">ToUTF8</a>();
...
puts(p); <span class="comment">// or call any other function taking const char *</span>
</pre></div> does <b>not</b> work because the temporary buffer returned by ToUTF8() is destroyed and <code>p</code> is left pointing nowhere. To correct this you may use <div class="fragment"><pre class="fragment">wxCharBuffer p(s.<a class="code" href="classwx_string.html#20ab14e8e240ef042bacda5a99e520d7">ToUTF8</a>());
puts(p);
</pre></div> which does work but results in an unnecessary copy of string data in the build configurations when ToUTF8() returns the pointer to internal string buffer. If this inefficiency is important you may write <div class="fragment"><pre class="fragment"><span class="keyword">const</span> wxUTF8Buf p(s.<a class="code" href="classwx_string.html#20ab14e8e240ef042bacda5a99e520d7">ToUTF8</a>());
puts(p);
</pre></div> where <code>wxUTF8Buf</code> is the type corresponding to the real return type of ToUTF8(). Similarly, wxWX2WCbuf can be used for the return type of wc_str(). But, once again, none of these cryptic types is really needed if you just pass the return value of any of the functions mentioned in this section to another function directly.<h2><a class="anchor" name="overview_unicode_settings">
Unicode Related Compilation Settings</a></h2>
<code>wxUSE_UNICODE</code> is now defined as 1 by default to indicate Unicode support. If UTF-8 is used for the internal storage in <a class="el" href="classwx_string.html">wxString</a>, <code>wxUSE_UNICODE_UTF8</code> is also defined, otherwise <code>wxUSE_UNICODE_WCHAR</code> is. </div>
<!-- ******************************************************* -->
<!--             Standard wxWidgets footer                   -->

<!-- NOTE: <br/> must go inside <p> but <hr/> must go outside -->
<p><br/></p><hr/>

<table width="100%" border="0">
<tr>
    <td align="left">
        <a href="http://www.wxwidgets.org/" style="margin-left: 0px">
            <img src="powered-by-wxwidgets.png" alt="wxWidgets logo" border="0"/>
        </a>
    </td>
    <td valign="middle" align="center"><p class="footer">Page generated <tt>Sat Sep 6 10:17:57 2008</tt> by <a href="http://www.doxygen.org/">Doxygen</a> 1.5.6</p></td>
    <td valign="middle" align="right"><p>[ <a href="wsdindex.html#top" class="top">top</a> ]</p></td>
</tr>
</table>

<script src="wxwidgets.js" type="text/javascript"></script>

<script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
    var pageTracker = _gat._getTracker("UA-794025-2");
    pageTracker._initData();
    pageTracker._trackPageview();
</script>

</body>
</html>

<!-- ***************************************************** -->
<!--         End of wxWidgets standard footer              -->
