<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- ****************************************************** -->
<!--            Standard wxWidgets header                   -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>wxWidgets: wxThread Class Reference</title>
    <meta name="author" content="wxWidgets team"/>
    <meta name="created" content="Sat Sep 6 08:16:08 2008"/>
    <meta name="keywords" content="wxWidgets"/>
    <link href="wxwidgets.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
</head>
<body>


<!--          End of wxWidgets standard header           -->
<!-- *************************************************** -->

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>wxThread Class Reference<br>
<small>
[<a class="el" href="group__group__class__threading.html">Threading</a>]</small>
</h1><!-- doxytag: class="wxThread" --><code>#include &lt;wx/thread.h&gt;</code>
<p>

<p>
<a href="classwx_thread-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
A thread is basically a path of execution through a program. Threads are sometimes called <em>light-weight</em> processes, but the fundamental difference between threads and processes is that memory spaces of different processes are separated while all threads share the same address space.<p>
While it makes it much easier to share common data between several threads, it also makes it much easier to shoot oneself in the foot, so careful use of synchronization objects such as mutexes() or <a class="el" href="classwx_critical_section.html">critical sections</a> is recommended. In addition, don't create global thread objects because they allocate memory in their constructor, which will cause problems for the memory checking system.<h2><a class="anchor" name="overview_typeswxthread">
Types of wxThreads</a></h2>
There are two types of threads in wxWidgets: <em>detached</em> and <em>joinable</em>, modeled after the the POSIX thread API. This is different from the Win32 API where all threads are joinable.<p>
By default wxThreads in wxWidgets use the detached behavior. Detached threads delete themselves once they have completed, either by themselves when they complete processing or through a call to <a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete()</a>, and thus must be created on the heap (through the new operator, for example). Conversely, joinable threads do not delete themselves when they are done processing and as such are safe to create on the stack. Joinable threads also provide the ability for one to get value it returned from <a class="el" href="classwx_thread.html#403b42e9b1ef20956ec58df6547db65d">Entry()</a> through <a class="el" href="classwx_thread.html#8ddb40929136e4e9f04b11cd66cb506b">Wait()</a>.<p>
You shouldn't hurry to create all the threads joinable, however, because this has a disadvantage as well: you <b>must</b> <a class="el" href="classwx_thread.html#8ddb40929136e4e9f04b11cd66cb506b">Wait()</a> for a joinable thread or the system resources used by it will never be freed, and you also must delete the corresponding <a class="el" href="classwx_thread.html">wxThread</a> object yourself if you did not create it on the stack. In contrast, detached threads are of the "fire-and-forget" kind: you only have to start a detached thread and it will terminate and destroy itself.<h2><a class="anchor" name="overview_deletionwxthread">
wxThread Deletion</a></h2>
Regardless of whether it has terminated or not, you should call <a class="el" href="classwx_thread.html#8ddb40929136e4e9f04b11cd66cb506b">Wait()</a> on a joinable thread to release its memory, as outlined in <a class="el" href="classwx_thread.html#overview_typeswxthread">Types of wxThreads</a>. If you created a joinable thread on the heap, remember to delete it manually with the delete operator or similar means as only detached threads handle this type of memory management.<p>
Since detached threads delete themselves when they are finished processing, you should take care when calling a routine on one. If you are certain the thread is still running and would like to end it, you may call <a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete()</a> to gracefully end it (which implies that the thread will be deleted after that call to <a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete()</a>). It should be implied that you should never attempt to delete a detached thread with the delete operator or similar means. As mentioned, <a class="el" href="classwx_thread.html#8ddb40929136e4e9f04b11cd66cb506b">Wait()</a> or <a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete()</a> attempts to gracefully terminate a joinable and detached thread, respectively. It does this by waiting until the thread in question calls <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac">TestDestroy()</a> or ends processing (returns from <a class="el" href="classwx_thread.html#403b42e9b1ef20956ec58df6547db65d">wxThread::Entry</a>).<p>
Obviously, if the thread does call <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac">TestDestroy()</a> and does not end the calling thread will come to halt. This is why it is important to call <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac">TestDestroy()</a> in the <a class="el" href="classwx_thread.html#403b42e9b1ef20956ec58df6547db65d">Entry()</a> routine of your threads as often as possible. As a last resort you can end the thread immediately through <a class="el" href="classwx_thread.html#2cbff8b3b0a93ab82f212c02f38a1ef4">Kill()</a>. It is strongly recommended that you do not do this, however, as it does not free the resources associated with the object (although the <a class="el" href="classwx_thread.html">wxThread</a> object of detached threads will still be deleted) and could leave the C runtime library in an undefined state.<h2><a class="anchor" name="overview_secondarythreads">
wxWidgets Calls in Secondary Threads</a></h2>
All threads other than the "main application thread" (the one <a class="el" href="classwx_app_console.html#99953775a2fd83fa2456e390779afe15">wxApp::OnInit</a> or your main function runs in, for example) are considered "secondary threads". These include all threads created by <a class="el" href="classwx_thread.html#88051a33aa3fa9ca9392ac7d47b43cf4">Create()</a> or the corresponding constructors.<p>
GUI calls, such as those to a <a class="el" href="classwx_window.html">wxWindow</a> or <a class="el" href="classwx_bitmap.html">wxBitmap</a> are explicitly not safe at all in secondary threads and could end your application prematurely. This is due to several reasons, including the underlying native API and the fact that <a class="el" href="classwx_thread.html">wxThread</a> does not run a GUI event loop similar to other APIs as MFC.<p>
A workaround for some wxWidgets ports is calling wxMutexGUIEnter() before any GUI calls and then calling wxMutexGUILeave() afterwords. However, the recommended way is to simply process the GUI calls in the main thread through an event that is posted by either <a class="el" href="group__group__funcmacro__misc.html#ge921d7bd0e52fedbf3f253d2c408bce1">wxQueueEvent()</a>. This does not imply that calls to these classes are thread-safe, however, as most wxWidgets classes are not thread-safe, including <a class="el" href="classwx_string.html">wxString</a>.<h2><a class="anchor" name="overview_pollwxThread">
Don't Poll a wxThread</a></h2>
A common problem users experience with <a class="el" href="classwx_thread.html">wxThread</a> is that in their main thread they will check the thread every now and then to see if it has ended through <a class="el" href="classwx_thread.html#0230733ffdc8f7603082dd2ca86b8cdd">IsRunning()</a>, only to find that their application has run into problems because the thread is using the default behavior and has already deleted itself. Naturally, they instead attempt to use joinable threads in place of the previous behavior. However, polling a <a class="el" href="classwx_thread.html">wxThread</a> for when it has ended is in general a bad idea - in fact calling a routine on any running <a class="el" href="classwx_thread.html">wxThread</a> should be avoided if possible. Instead, find a way to notify yourself when the thread has ended.<p>
Usually you only need to notify the main thread, in which case you can post an event to it via <a class="el" href="group__group__funcmacro__misc.html#g0cf60a1ad3a5f1e659f7ae591570f58d">wxPostEvent()</a> or <a class="el" href="classwx_evt_handler.html#0737c6d2cbcd5ded4b1ecdd53ed0def3">wxEvtHandler::AddPendingEvent</a>. In the case of secondary threads you can call a routine of another class when the thread is about to complete processing and/or set the value of a variable, possibly using mutexes() and/or other synchronization means if necessary.<p>
<div><span class="lib">Library:</span>&nbsp;&nbsp;<span class="lib_text"><a class="el" href="page_libs.html#page_libs_wxbase">wxBase</a></span></div><p>
<div><span class="category">Category:</span>&nbsp;&nbsp;<span class="category_text"><a class="el" href="group__group__class__threading.html">Threading</a></span></div> <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classwx_mutex.html">wxMutex</a>, <a class="el" href="classwx_condition.html">wxCondition</a>, <a class="el" href="classwx_critical_section.html">wxCriticalSection</a> </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#afdb64801bd4d595ad0956f71d5791f0">wxThread</a> (<a class="el" href="interface_2wx_2thread_8h.html#0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a> kind=wxTHREAD_DETACHED)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#be16c9e4b808402d875ed2ccf4010285">~wxThread</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#88051a33aa3fa9ca9392ac7d47b43cf4">Create</a> (unsigned int stackSize=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ExitCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#403b42e9b1ef20956ec58df6547db65d">Entry</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#888b9b94f64a2b61bd4740de1149e6e2">Exit</a> (ExitCode exitcode=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#e65e49c0aa6b1783036de6d6df3c91e0">GetId</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#de0b4c2a853b9a5289be2cabdd7fcf8b">GetPriority</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#dc6cf71c426b1da03c6ca4b7f7da8aab">IsAlive</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#315c2abb553ba7e17ab2d5b2a0728e73">IsDetached</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#34328ecb720a1066971fb5e48cd84b6f">IsPaused</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#0230733ffdc8f7603082dd2ca86b8cdd">IsRunning</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#2cbff8b3b0a93ab82f212c02f38a1ef4">Kill</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#08be8e9cbed7bd769228266528b7f0e0">OnExit</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#8c6d835578dde71dd2c241c38336a4ba">Pause</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#fe81d37cd6cb6d5eb142773fb2c94562">Resume</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#5d894750ffaac8fc42ee85aeff8bb4c0">Run</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#ad6c6ea22fb4bce74514331fdd42cf34">SetPriority</a> (int priority)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac">TestDestroy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ExitCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#8ddb40929136e4e9f04b11cd66cb506b">Wait</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#16f60e53cff660e95fcbc3738aeb216a">Yield</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#21ccbc2f91bed8d65aeada49a7f8335d">GetCPUCount</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#d9c567a9aca7c09bd0057b9381d3aa99">GetCurrentId</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#1ee917ef87f986ba3b2ee26e620378e4">IsMain</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#09dfe3800bbfad53be303a4608d52959">SetConcurrency</a> (size_t level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#9ae47b39270c54dba5534af31f885ec6">Sleep</a> (unsigned long milliseconds)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classwx_thread.html">wxThread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#7077fa46ffef0fd1d023628776598335">This</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="afdb64801bd4d595ad0956f71d5791f0"></a><!-- doxytag: member="wxThread::wxThread" ref="afdb64801bd4d595ad0956f71d5791f0" args="(wxThreadKind kind=wxTHREAD_DETACHED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxThread::wxThread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_2wx_2thread_8h.html#0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>wxTHREAD_DETACHED</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This constructor creates a new detached (default) or joinable C++ thread object. It does not create or start execution of the real thread -- for this you should use the <a class="el" href="classwx_thread.html#88051a33aa3fa9ca9392ac7d47b43cf4">Create()</a> and <a class="el" href="classwx_thread.html#5d894750ffaac8fc42ee85aeff8bb4c0">Run()</a> methods.<p>
The possible values for <em>kind</em> parameters are:<ul>
<li><b>wxTHREAD_DETACHED</b> - Creates a detached thread.</li><li><b>wxTHREAD_JOINABLE</b> - Creates a joinable thread. </li></ul>

</div>
</div><p>
<a class="anchor" name="be16c9e4b808402d875ed2ccf4010285"></a><!-- doxytag: member="wxThread::~wxThread" ref="be16c9e4b808402d875ed2ccf4010285" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxThread::~wxThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The destructor frees the resources associated with the thread. Notice that you should never delete a detached thread -- you may only call <a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete()</a> on it or wait until it terminates (and auto destructs) itself. Because the detached threads delete themselves, they can only be allocated on the heap. Joinable threads should be deleted explicitly. The <a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete()</a> and <a class="el" href="classwx_thread.html#2cbff8b3b0a93ab82f212c02f38a1ef4">Kill()</a> functions will not delete the C++ thread object. It is also safe to allocate them on stack. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="88051a33aa3fa9ca9392ac7d47b43cf4"></a><!-- doxytag: member="wxThread::Create" ref="88051a33aa3fa9ca9392ac7d47b43cf4" args="(unsigned int stackSize=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Create           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>stackSize</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new thread. The thread object is created in the suspended state, and you should call <a class="el" href="classwx_thread.html#5d894750ffaac8fc42ee85aeff8bb4c0">Run()</a> to start running it. You may optionally specify the stack size to be allocated to it (Ignored on platforms that don't support setting it explicitly, eg. Unix system without <code>pthread_attr_setstacksize</code>). If you do not specify the stack size, the system's default value is used. <b>Warning:</b> It is a good idea to explicitly specify a value as systems' default values vary from just a couple of KB on some systems (BSD and OS/2 systems) to one or several MB (Windows, Solaris, Linux). So, if you have a thread that requires more than just a few KB of memory, you will have mysterious problems on some platforms but not on the common ones. On the other hand, just indicating a large stack size by default will give you performance issues on those systems with small default stack since those typically use fully committed memory for the stack. On the contrary, if use a lot of threads (say several hundred), virtual adress space can get tight unless you explicitly specify a smaller amount of thread stack space for each thread.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>One of:<ul>
<li><b>wxTHREAD_NO_ERROR</b> - No error.</li><li><b>wxTHREAD_NO_RESOURCE</b> - There were insufficient resources to create the thread.</li><li><b>wxTHREAD_NO_RUNNING</b> - The thread is already running </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="906f0801d71157be46a050914315c013"></a><!-- doxytag: member="wxThread::Delete" ref="906f0801d71157be46a050914315c013" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Delete           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling <a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete()</a> gracefully terminates a detached thread, either when the thread calls <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac">TestDestroy()</a> or finished processing. (Note that while this could work on a joinable thread you simply should not call this routine on one as afterwards you may not be able to call <a class="el" href="classwx_thread.html#8ddb40929136e4e9f04b11cd66cb506b">Wait()</a> to free the memory of that thread). See <a class="el" href="classwx_thread.html#overview_deletionwxthread">wxThread deletion</a> for a broader explanation of this routine. 
</div>
</div><p>
<a class="anchor" name="403b42e9b1ef20956ec58df6547db65d"></a><!-- doxytag: member="wxThread::Entry" ref="403b42e9b1ef20956ec58df6547db65d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ExitCode wxThread::Entry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the entry point of the thread. This function is pure virtual and must be implemented by any derived class. The thread execution will start here. The returned value is the thread exit code which is only useful for joinable threads and is the value returned by <a class="el" href="classwx_thread.html#8ddb40929136e4e9f04b11cd66cb506b">Wait()</a>. This function is called by wxWidgets itself and should never be called directly. 
</div>
</div><p>
<a class="anchor" name="888b9b94f64a2b61bd4740de1149e6e2"></a><!-- doxytag: member="wxThread::Exit" ref="888b9b94f64a2b61bd4740de1149e6e2" args="(ExitCode exitcode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wxThread::Exit           </td>
          <td>(</td>
          <td class="paramtype">ExitCode&nbsp;</td>
          <td class="paramname"> <em>exitcode</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a protected function of the <a class="el" href="classwx_thread.html">wxThread</a> class and thus can only be called from a derived class. It also can only be called in the context of this thread, i.e. a thread can only exit from itself, not from another thread. This function will terminate the OS thread (i.e. stop the associated path of execution) and also delete the associated C++ object for detached threads. <a class="el" href="classwx_thread.html#08be8e9cbed7bd769228266528b7f0e0">OnExit()</a> will be called just before exiting. 
</div>
</div><p>
<a class="anchor" name="21ccbc2f91bed8d65aeada49a7f8335d"></a><!-- doxytag: member="wxThread::GetCPUCount" ref="21ccbc2f91bed8d65aeada49a7f8335d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int wxThread::GetCPUCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of system CPUs or -1 if the value is unknown.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classwx_thread.html#09dfe3800bbfad53be303a4608d52959">SetConcurrency()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d9c567a9aca7c09bd0057b9381d3aa99"></a><!-- doxytag: member="wxThread::GetCurrentId" ref="d9c567a9aca7c09bd0057b9381d3aa99" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned long wxThread::GetCurrentId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the platform specific thread ID of the current thread as a long. This can be used to uniquely identify threads, even if they are not wxThreads. 
</div>
</div><p>
<a class="anchor" name="e65e49c0aa6b1783036de6d6df3c91e0"></a><!-- doxytag: member="wxThread::GetId" ref="e65e49c0aa6b1783036de6d6df3c91e0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long wxThread::GetId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the thread identifier: this is a platform dependent number that uniquely identifies the thread throughout the system during its existence (i.e. the thread identifiers may be reused). 
</div>
</div><p>
<a class="anchor" name="de0b4c2a853b9a5289be2cabdd7fcf8b"></a><!-- doxytag: member="wxThread::GetPriority" ref="de0b4c2a853b9a5289be2cabdd7fcf8b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wxThread::GetPriority           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the priority of the thread, between zero and 100.<p>
The following priorities are defined:<ul>
<li><b>WXTHREAD_MIN_PRIORITY:</b> 0</li><li><b>WXTHREAD_DEFAULT_PRIORITY:</b> 50</li><li><b>WXTHREAD_MAX_PRIORITY:</b> 100 </li></ul>

</div>
</div><p>
<a class="anchor" name="dc6cf71c426b1da03c6ca4b7f7da8aab"></a><!-- doxytag: member="wxThread::IsAlive" ref="dc6cf71c426b1da03c6ca4b7f7da8aab" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsAlive           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <span class="literal">true</span> if the thread is alive (i.e. started and not terminating). Note that this function can only safely be used with joinable threads, not detached ones as the latter delete themselves and so when the real thread is no longer alive, it is not possible to call this function because the <a class="el" href="classwx_thread.html">wxThread</a> object no longer exists. 
</div>
</div><p>
<a class="anchor" name="315c2abb553ba7e17ab2d5b2a0728e73"></a><!-- doxytag: member="wxThread::IsDetached" ref="315c2abb553ba7e17ab2d5b2a0728e73" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsDetached           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <span class="literal">true</span> if the thread is of the detached kind, <span class="literal">false</span> if it is a joinable one. 
</div>
</div><p>
<a class="anchor" name="1ee917ef87f986ba3b2ee26e620378e4"></a><!-- doxytag: member="wxThread::IsMain" ref="1ee917ef87f986ba3b2ee26e620378e4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool wxThread::IsMain           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <span class="literal">true</span> if the calling thread is the main application thread. 
</div>
</div><p>
<a class="anchor" name="34328ecb720a1066971fb5e48cd84b6f"></a><!-- doxytag: member="wxThread::IsPaused" ref="34328ecb720a1066971fb5e48cd84b6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsPaused           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <span class="literal">true</span> if the thread is paused. 
</div>
</div><p>
<a class="anchor" name="0230733ffdc8f7603082dd2ca86b8cdd"></a><!-- doxytag: member="wxThread::IsRunning" ref="0230733ffdc8f7603082dd2ca86b8cdd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsRunning           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <span class="literal">true</span> if the thread is running. This method may only be safely used for joinable threads, see the remark in <a class="el" href="classwx_thread.html#dc6cf71c426b1da03c6ca4b7f7da8aab">IsAlive()</a>. 
</div>
</div><p>
<a class="anchor" name="2cbff8b3b0a93ab82f212c02f38a1ef4"></a><!-- doxytag: member="wxThread::Kill" ref="2cbff8b3b0a93ab82f212c02f38a1ef4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Kill           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Immediately terminates the target thread. <b>This</b> function is dangerous and should be used with extreme care (and not used at all whenever possible)! The resources allocated to the thread will not be freed and the state of the C runtime library may become inconsistent. Use <a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete()</a> for detached threads or <a class="el" href="classwx_thread.html#8ddb40929136e4e9f04b11cd66cb506b">Wait()</a> for joinable threads instead. For detached threads <a class="el" href="classwx_thread.html#2cbff8b3b0a93ab82f212c02f38a1ef4">Kill()</a> will also delete the associated C++ object. However this will not happen for joinable threads and this means that you will still have to delete the <a class="el" href="classwx_thread.html">wxThread</a> object yourself to avoid memory leaks. In neither case <a class="el" href="classwx_thread.html#08be8e9cbed7bd769228266528b7f0e0">OnExit()</a> of the dying thread will be called, so no thread-specific cleanup will be performed. This function can only be called from another thread context, i.e. a thread cannot kill itself. It is also an error to call this function for a thread which is not running or paused (in the latter case, the thread will be resumed first) -- if you do it, a <b>wxTHREAD_NOT_RUNNING</b> error will be returned. 
</div>
</div><p>
<a class="anchor" name="08be8e9cbed7bd769228266528b7f0e0"></a><!-- doxytag: member="wxThread::OnExit" ref="08be8e9cbed7bd769228266528b7f0e0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wxThread::OnExit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when the thread exits. This function is called in the context of the thread associated with the <a class="el" href="classwx_thread.html">wxThread</a> object, not in the context of the main thread. This function will not be called if the thread was <a class="el" href="classwx_thread.html#2cbff8b3b0a93ab82f212c02f38a1ef4">Kill()</a> killed. This function should never be called directly. 
</div>
</div><p>
<a class="anchor" name="8c6d835578dde71dd2c241c38336a4ba"></a><!-- doxytag: member="wxThread::Pause" ref="8c6d835578dde71dd2c241c38336a4ba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Pause           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suspends the thread. Under some implementations (Win32), the thread is suspended immediately, under others it will only be suspended when it calls <a class="el" href="classwx_thread.html#9a3acec44b06b2a2430c5659991a3eac">TestDestroy()</a> for the next time (hence, if the thread doesn't call it at all, it won't be suspended). This function can only be called from another thread context. 
</div>
</div><p>
<a class="anchor" name="fe81d37cd6cb6d5eb142773fb2c94562"></a><!-- doxytag: member="wxThread::Resume" ref="fe81d37cd6cb6d5eb142773fb2c94562" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Resume           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resumes a thread suspended by the call to <a class="el" href="classwx_thread.html#8c6d835578dde71dd2c241c38336a4ba">Pause()</a>. This function can only be called from another thread context. 
</div>
</div><p>
<a class="anchor" name="5d894750ffaac8fc42ee85aeff8bb4c0"></a><!-- doxytag: member="wxThread::Run" ref="5d894750ffaac8fc42ee85aeff8bb4c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Run           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts the thread execution. Should be called after <a class="el" href="classwx_thread.html#88051a33aa3fa9ca9392ac7d47b43cf4">Create()</a>. This function can only be called from another thread context. 
</div>
</div><p>
<a class="anchor" name="09dfe3800bbfad53be303a4608d52959"></a><!-- doxytag: member="wxThread::SetConcurrency" ref="09dfe3800bbfad53be303a4608d52959" args="(size_t level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool wxThread::SetConcurrency           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the thread concurrency level for this process. This is, roughly, the number of threads that the system tries to schedule to run in parallel. The value of 0 for <em>level</em> may be used to set the default one. Returns <span class="literal">true</span> on success or <span class="literal">false</span> otherwise (for example, if this function is not implemented for this platform -- currently everything except Solaris). 
</div>
</div><p>
<a class="anchor" name="ad6c6ea22fb4bce74514331fdd42cf34"></a><!-- doxytag: member="wxThread::SetPriority" ref="ad6c6ea22fb4bce74514331fdd42cf34" args="(int priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wxThread::SetPriority           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>priority</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the priority of the thread, between 0 and 100. It can only be set after calling <a class="el" href="classwx_thread.html#88051a33aa3fa9ca9392ac7d47b43cf4">Create()</a> but before calling <a class="el" href="classwx_thread.html#5d894750ffaac8fc42ee85aeff8bb4c0">Run()</a>.<p>
The following priorities are defined:<ul>
<li><b>WXTHREAD_MIN_PRIORITY:</b> 0</li><li><b>WXTHREAD_DEFAULT_PRIORITY:</b> 50</li><li><b>WXTHREAD_MAX_PRIORITY:</b> 100 </li></ul>

</div>
</div><p>
<a class="anchor" name="9ae47b39270c54dba5534af31f885ec6"></a><!-- doxytag: member="wxThread::Sleep" ref="9ae47b39270c54dba5534af31f885ec6" args="(unsigned long milliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void wxThread::Sleep           </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>milliseconds</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pauses the thread execution for the given amount of time.<p>
This is the same as <a class="el" href="group__group__funcmacro__time.html#g66778879349f76fd833902d3767006fa">wxMilliSleep()</a>. 
</div>
</div><p>
<a class="anchor" name="9a3acec44b06b2a2430c5659991a3eac"></a><!-- doxytag: member="wxThread::TestDestroy" ref="9a3acec44b06b2a2430c5659991a3eac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool wxThread::TestDestroy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function should be called periodically by the thread to ensure that calls to <a class="el" href="classwx_thread.html#8c6d835578dde71dd2c241c38336a4ba">Pause()</a> and <a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete()</a> will work. If it returns <span class="literal">true</span>, the thread should exit as soon as possible. Notice that under some platforms (POSIX), implementation of <a class="el" href="classwx_thread.html#8c6d835578dde71dd2c241c38336a4ba">Pause()</a> also relies on this function being called, so not calling it would prevent both stopping and suspending thread from working. 
</div>
</div><p>
<a class="anchor" name="7077fa46ffef0fd1d023628776598335"></a><!-- doxytag: member="wxThread::This" ref="7077fa46ffef0fd1d023628776598335" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classwx_thread.html">wxThread</a>* wxThread::This           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the thread object for the calling thread. <span class="literal">NULL</span> is returned if the calling thread is the main (GUI) thread, but <a class="el" href="classwx_thread.html#1ee917ef87f986ba3b2ee26e620378e4">IsMain()</a> should be used to test whether the thread is really the main one because <span class="literal">NULL</span> may also be returned for the thread not created with <a class="el" href="classwx_thread.html">wxThread</a> class. Generally speaking, the return value for such a thread is undefined. 
</div>
</div><p>
<a class="anchor" name="8ddb40929136e4e9f04b11cd66cb506b"></a><!-- doxytag: member="wxThread::Wait" ref="8ddb40929136e4e9f04b11cd66cb506b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ExitCode wxThread::Wait           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits for a joinable thread to terminate and returns the value the thread returned from <a class="el" href="classwx_thread.html#403b42e9b1ef20956ec58df6547db65d">Entry()</a> or <code></code>(ExitCode)-1 on error. Notice that, unlike <a class="el" href="classwx_thread.html#906f0801d71157be46a050914315c013">Delete()</a> doesn't cancel the thread in any way so the caller waits for as long as it takes to the thread to exit. You can only <a class="el" href="classwx_thread.html#8ddb40929136e4e9f04b11cd66cb506b">Wait()</a> for joinable (not detached) threads. This function can only be called from another thread context. See <a class="el" href="classwx_thread.html#overview_deletionwxthread">wxThread deletion</a> for a broader explanation of this routine. 
</div>
</div><p>
<a class="anchor" name="16f60e53cff660e95fcbc3738aeb216a"></a><!-- doxytag: member="wxThread::Yield" ref="16f60e53cff660e95fcbc3738aeb216a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wxThread::Yield           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Give the rest of the thread time slice to the system allowing the other threads to run. Note that using this function is <b>strongly</b> discouraged, since in many cases it indicates a design weakness of your threading model (as does using Sleep functions). Threads should use the CPU in an efficient manner, i.e. they should do their current work efficiently, then as soon as the work is done block on a wakeup event (<a class="el" href="classwx_condition.html">wxCondition</a>, <a class="el" href="classwx_mutex.html">wxMutex</a>, select(), poll(), ...) which will get signalled e.g. by other threads or a user device once further thread work is available. Using Yield or Sleep indicates polling-type behaviour, since we're fuzzily giving up our timeslice and wait until sometime later we'll get reactivated, at which time we realize that there isn't really much to do and Yield again... The most critical characteristic of Yield is that it's operating system specific: there may be scheduler changes which cause your thread to not wake up relatively soon again, but instead many seconds later, causing huge performance issues for your application. <b>with</b> a well-behaving, CPU-efficient thread the operating system is likely to properly care for its reactivation the moment it needs it, whereas with non-deterministic, Yield-using threads all bets are off and the system scheduler is free to penalize drastically, and this effect gets worse with increasing system load due to less free CPU resources available. You may refer to various Linux kernel sched_yield discussions for more information. See also <a class="el" href="classwx_thread.html#9ae47b39270c54dba5534af31f885ec6">Sleep()</a>. 
</div>
</div><p>
</div>
<!-- ******************************************************* -->
<!--             Standard wxWidgets footer                   -->

<!-- NOTE: <br/> must go inside <p> but <hr/> must go outside -->
<p><br/></p><hr/>

<table width="100%" border="0">
<tr>
    <td align="left">
        <a href="http://www.wxwidgets.org/" style="margin-left: 0px">
            <img src="powered-by-wxwidgets.png" alt="wxWidgets logo" border="0"/>
        </a>
    </td>
    <td valign="middle" align="center"><p class="footer">Page generated <tt>Sat Sep 6 08:16:08 2008</tt> by <a href="http://www.doxygen.org/">Doxygen</a> 1.5.6</p></td>
    <td valign="middle" align="right"><p>[ <a href="wsdindex.html#top" class="top">top</a> ]</p></td>
</tr>
</table>

<script src="wxwidgets.js" type="text/javascript"></script>

<script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
    var pageTracker = _gat._getTracker("UA-794025-2");
    pageTracker._initData();
    pageTracker._trackPageview();
</script>

</body>
</html>

<!-- ***************************************************** -->
<!--         End of wxWidgets standard footer              -->
