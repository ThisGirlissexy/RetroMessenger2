<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- ****************************************************** -->
<!--            Standard wxWidgets header                   -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>wxWidgets: Platform Details</title>
    <meta name="author" content="wxWidgets team"/>
    <meta name="created" content="Sat Sep 6 08:15:37 2008"/>
    <meta name="keywords" content="wxWidgets"/>
    <link href="wxwidgets.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
</head>
<body>


<!--          End of wxWidgets standard header           -->
<!-- *************************************************** -->

<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">wxWidgets 2.9.0: A portable C++ GUI toolkit</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="page_port">Platform Details </a></h1>wxWidgets defines a common API across platforms, but uses the native graphical user interface (GUI) on each platform, so your program will take on the native look and feel that users are familiar with. Unfortunately native toolkits and hardware do not always support the functionality that the wxWidgets API requires. This chapter collects notes about differences among supported platforms and ports.<p>
<ul>
<li><a class="el" href="page_port.html#page_port_wxgtk">wxGTK</a> </li>
<li><a class="el" href="page_port.html#page_port_wxmac">wxMac</a> </li>
<li><a class="el" href="page_port.html#page_port_wxcocoa">wxCocoa</a> </li>
<li><a class="el" href="page_port.html#page_port_wxos2">wxOS2</a> </li>
<li><a class="el" href="page_port.html#page_port_wxmgl">wxMGL</a> </li>
<li><a class="el" href="page_port.html#page_port_wxx11">wxX11</a> </li>
<li><a class="el" href="page_port.html#page_port_wxmsw">wxMSW</a> </li>
<li><a class="el" href="page_port.html#page_port_nativedocs">Documentation for the native toolkits</a></li>
</ul>
<hr>
<h2><a class="anchor" name="page_port_wxgtk">
wxGTK</a></h2>
 
<img src="gtk_logo.png" alt="GTK logo" title="GTK logo" class="logo">
<p>
wxGTK is a port of wxWidgets using the GTK+ library. It makes use of GTK+'s native widgets wherever possible and uses wxWidgets' generic controls when needed. GTK+ itself has been ported to a number of systems, but so far only the original X11 version is supported. Support for other GTK+ backends is planned, such as the new DirectFB backend.<p>
All work is being done on GTK+ version 2.0 and above. Support for GTK+ 1.2 will be deprecated in a later release.<p>
You will need GTK+ 2.6 or higher which is available from:<p>
<a href="http://www.gtk.org/">http://www.gtk.org</a><p>
The newer version of GTK+ you use, the more native widgets and features will be utilized. We have gone to a great extent to allow compiling wxWidgets applications with a latest version of GTK+, with the resulting binary working on systems even with a much lower version of GTK+. You will have to ensure that the application is launched with lazy symbol binding for that.<p>
In order to configure wxWidgets to compile wxGTK you will need use the <code>--with-gtk</code> argument to the <code>configure</code> script. This is the default for many systems.<p>
GTK+ 1.2 can still be used, albeit discouraged. For that you can pass <code>--with-gtk=1</code> to the <code>configure</code> script.<p>
For further information, please see the files in docs/gtk in the distribution.<h2><a class="anchor" name="page_port_wxmac">
wxMac</a></h2>
 
<img src="osxleopard_logo.png" alt="Mac OS X (Leopard) logo"
    title="Mac OS X (Leopard) logo" class="logo">
<p>
wxMac is a port of wxWidgets for the Macintosh OS platform. Currently MacOS X 10.4 or higher are supported. wxMac can be compiled both using Apple's command line developer tools as well as Apple's XCode IDE. wxMac supports both the Intel and PowerPC architectures and can be used to produce "universal binaries" in order create application which can run both architecture. Unfortunately, wxMac does not support any 64-bit architecture since Apple decided not to port its Carbon API entirely to 64-bit.<p>
For further information, please see the files in docs/mac in the distribution.<h2><a class="anchor" name="page_port_wxcocoa">
wxCocoa</a></h2>
 
<img src="osxleopard_logo.png" alt="Mac OS X (Leopard) logo"
    title="Mac OS X (Leopard) logo" class="logo">
<p>
wxCocoa is another port of wxWidgets for the Macintosh OS platform. But in contrat to wxMac, it uses the Cocoa API. Much work has gone into this port and many controls are functional, but the port has not reached the maturity of the wxMac port yet. It should be possible to use wxCocoa on 64-bit architectures.<h2><a class="anchor" name="page_port_wxmgl">
wxMGL</a></h2>
wxMGL is a port of wxWidgets using the MGL library available from SciTech as the underlying graphics backend. wxMGL draws its widgets using the wxUniversal widget set which is part of wxWidgets. MGL itself runs on a variety of platforms including DOS, Linux hardware (similar to the Linux framebuffer) and various graphics systems such as Win32, X11 and OS/2. Note that currently MGL for Linux runs only on x86-based systems.<p>
You will MGL 5.0 or higher which is available from<p>
<a href="http://www.scitechsoft.com/products/product_download.html">http://www.scitechsoft.com/products/product_download.html</a><p>
In order to configure wxWidgets to compile wxMGL you will need to type:<p>
<div class="fragment"><pre class="fragment">configure --with-mgl --with-universal </pre></div><p>
Under DOS, wxMGL uses a dmake based make system.<p>
For further information, please see the files in docs/mgl in the distribution.<h2><a class="anchor" name="page_port_wxos2">
wxOS2</a></h2>
wxOS2 is a port of wxWidgets for the IBM OS/2 Warp3 and Warp4 platforms. This port is currently under construction and in beta phase.<h2><a class="anchor" name="page_port_wxx11">
wxX11</a></h2>
 
<img src="x11_logo.png" alt="X.org logo" title="X.org logo" class="logo">
<p>
wxX11 is a port of wxWidgets using X11 (The X Window System) as the underlying graphics backend. wxX11 draws its widgets using the wxUniversal widget set which is now part of wxWidgets. wxX11 is well-suited for a number of special applications such as those running on systems with few resources (PDAs) or for applications which need to use a special themed look.<p>
In order to configure wxWidgets to compile wxX11 you will need to type:<p>
<div class="fragment"><pre class="fragment">configure --with-x11 --with-universal </pre></div><p>
For further information, please see the files in docs/x11 in the distribution. There is also a page on the use of wxWidgets for embedded applications on the wxWidgets web site.<h2><a class="anchor" name="page_port_wxmsw">
wxMSW</a></h2>
 
<img src="win_logo.png" alt="Windows logo" title="Windows logo" class="logo">
<p>
wxMSW is a port of wxWidgets for the Windows platforms including Windows 95, 98, ME, 2000, NT, XP in ANSI and Unicode mode (for Windows 95 through the MSLU extension library). wxMSW ensures native look and feel for XP as well when using wxWidgets version 2.3.3 or higher. wxMSW can be compile with a great variety of compilers including MS VC++, Borland 5.5, MinGW32, Cygwin and Watcom as well as cross-compilation with a Linux hosted MinGW32 tool chain.<p>
For further information, please see the files in docs/msw in the distribution.<h3><a class="anchor" name="page_port_wxmsw_themedborders">
Themed borders on Windows</a></h3>
Starting with wxWidgets 2.8.5, you can specify the <code>wxBORDER_THEME</code> style to have wxWidgets use a themed border. Using the default XP theme, this is a thin 1-pixel blue border, with an extra 1-pixel border in the window client background colour (usually white) to separate the client area's scrollbars from the border.<p>
If you don't specify a border style for a <a class="el" href="classwx_text_ctrl.html">wxTextCtrl</a> in rich edit mode, wxWidgets now gives the control themed borders automatically, where previously they would take the Windows 95-style sunken border. Other native controls such as <a class="el" href="classwx_text_ctrl.html">wxTextCtrl</a> in non-rich edit mode, and <a class="el" href="classwx_combo_box.html">wxComboBox</a>, already paint themed borders where appropriate. To use themed borders on other windows, such as <a class="el" href="classwx_panel.html">wxPanel</a>, pass the <code>wxBORDER_THEME</code> style, or (apart from <a class="el" href="classwx_panel.html">wxPanel</a>) pass no border style.<p>
In general, specifying <code>wxBORDER_THEME</code> will cause a border of some kind to be used, chosen by the platform and control class. To leave the border decision entirely to wxWidgets, pass <code>wxBORDER_DEFAULT</code>. This is not to be confused with specifying <code>wxBORDER_NONE</code>, which says that there should definitely be <em>no</em> border.<h4><a class="anchor" name="page_port_wxmsw_themedborders_details">
More detail on border implementation</a></h4>
The way that wxMSW decides whether to apply a themed border is as follows. The theming code calls wxWindow::GetBorder() to obtain a border. If no border style has been passed to the window constructor, GetBorder() calls GetDefaultBorder() for this window. If wxBORDER_THEME was passed to the window constructor, GetBorder() calls GetDefaultBorderForControl().<p>
The implementation of wxWindow::GetDefaultBorder() on wxMSW calls wxWindow::CanApplyThemeBorder() which is a virtual function that tells wxWidgets whether a control can have a theme applied explicitly (some native controls already paint a theme in which case we should not apply it ourselves). Note that <a class="el" href="classwx_panel.html">wxPanel</a> is an exception to this rule because in many cases we wish to create a window with no border (for example, notebook pages). So <a class="el" href="classwx_panel.html">wxPanel</a> overrides GetDefaultBorder() in order to call the generic wxWindowBase::GetDefaultBorder(), returning wxBORDER_NONE.<h3><a class="anchor" name="page_port_wxmsw_wince">
wxWinCE</a></h3>
wxWinCE is the name given to wxMSW when compiled on Windows CE devices; most of wxMSW is common to Win32 and Windows CE but there are some simplifications, enhancements, and differences in behaviour.<p>
For building instructions, see docs/msw/wince in the distribution, also the section about Visual Studio 2005 project files below. The rest of this section documents issues you need to be aware of when programming for Windows CE devices.<h4><a class="anchor" name="page_port_wxmsw_wince_">
General issues for wxWinCE programming</a></h4>
Mobile applications generally have fewer features and simpler user interfaces. Simply omit whole sizers, static lines and controls in your dialogs, and use comboboxes instead of listboxes where appropriate. You also need to reduce the amount of spacing used by sizers, for which you can use a macro such as this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#if defined(__WXWINCE__)</span>
<span class="preprocessor"></span><span class="preprocessor">    #define wxLARGESMALL(large,small) small</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">    #define wxLARGESMALL(large,small) large</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">// Usage</span>
topsizer-&gt;Add( CreateTextSizer( message ), 0, wxALL, wxLARGESMALL(10,0) );
</pre></div><p>
There is only ever one instance of a Windows CE application running, and wxWidgets will take care of showing the current instance and shutting down the second instance if necessary.<p>
You can test the return value of <a class="el" href="classwx_system_settings.html#f8a2e5d2411eb520b8dad5fc5e9a1a7a">wxSystemSettings::GetScreenType()</a> for a qualitative assessment of what kind of display is available, or use <a class="el" href="group__group__funcmacro__gdi.html#gefd6b970b2fa62bfc00f386da06ab286">wxGetDisplaySize()</a> if you need more information.<p>
You can also use wxGetOsVersion to test for a version of Windows CE at run-time (see the next section). However, because different builds are currently required to target different kinds of device, these values are hard-wired according to the build, and you cannot dynamically adapt the same executable for different major Windows CE platforms. This would require a different approach to the way wxWidgets adapts its behaviour (such as for menubars) to suit the style of device.<p>
See the "Life!" example (demos/life) for an example of an application that has been tailored for PocketPC and Smartphone use.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>don't forget to have this line in your .rc file, as for desktop Windows applications:</dd></dl>
<div class="fragment"><pre class="fragment">#include "wx/msw/wx.rc" </pre></div><h4><a class="anchor" name="page_port_wxmsw_wince_sdk">
Testing for WinCE SDKs</a></h4>
Use these preprocessor symbols to test for the different types of device or SDK:<p>
<ul>
<li><b>__SMARTPHONE__</b> Generic mobile devices with phone buttons and a small display </li>
<li><b>__PDA__</b> Generic mobile devices with no phone </li>
<li><b>__HANDHELDPC__</b> Generic mobile device with a keyboard </li>
<li><b>__WXWINCE__</b> Microsoft-powered Windows CE devices, whether PocketPC, Smartphone or Standard SDK </li>
<li><b>WIN32_PLATFORM_WFSP</b> Microsoft-powered smartphone </li>
<li><b>__POCKETPC__</b> Microsoft-powered PocketPC devices with touch-screen </li>
<li><b>__WINCE_STANDARDSDK__</b> Microsoft-powered Windows CE devices, for generic Windows CE applications </li>
<li><b>__WINCE_NET__</b> Microsoft-powered Windows CE .NET devices (_WIN32_WCE is 400 or greater)</li>
</ul>
wxGetOsVersion will return these values:<p>
<ul>
<li><b>wxWINDOWS_POCKETPC</b> The application is running under PocketPC. </li>
<li><b>wxWINDOWS_SMARTPHONE</b> The application is running under Smartphone. </li>
<li><b>wxWINDOWS_CE</b> The application is running under Windows CE (built with the Standard SDK).</li>
</ul>
<h4><a class="anchor" name="page_port_wxmsw_wince_sizing">
Window sizing in wxWinCE</a></h4>
Top level windows (dialogs, frames) are created always full-screen. Fit() of sizers will not rescale top level windows but instead will scale window content.<p>
If the screen orientation changes, the windows will automatically be resized so no further action needs to be taken (unless you want to change the layout according to the orientation, which you could detect in idle time, for example). When input panel (SIP) is shown, top level windows (frames and dialogs) resize accordingly (see <a class="el" href="classwx_top_level_window.html#c804159a17302c7e805d70ff4911318c">wxTopLevelWindow::HandleSettingChange()</a>).<h4><a class="anchor" name="page_port_wxmsw_wince_toplevel">
Closing top-level windows in wxWinCE</a></h4>
You won't get a <a class="el" href="classwx_close_event.html">wxCloseEvent</a> when the user clicks on the X in the titlebar on Smartphone and PocketPC; the window is simply hidden instead. However the system may send the event to force the application to close down.<h4><a class="anchor" name="page_port_wxmsw_wince_hibernation">
Hibernation in wxWinCE</a></h4>
Smartphone and PocketPC will send a <code>wxEVT_HIBERNATE</code> to the application object in low memory conditions. Your application should release memory and close dialogs, and wake up again when the next <code>wxEVT_ACTIVATE</code> or <code>wxEVT_ACTIVATE_APP</code> message is received. (<code>wxEVT_ACTIVATE_APP</code> is generated whenever a <code>wxEVT_ACTIVATE</code> event is received in Smartphone and PocketPC, since these platforms do not support <code>WM_ACTIVATEAPP</code>.)<h4><a class="anchor" name="page_port_wxmsw_wince_hwbutt">
Hardware buttons in wxWinCE</a></h4>
Special hardware buttons are sent to a window via the <code>wxEVT_HOTKEY</code> event under Smartphone and PocketPC. You should first register each required button with <a class="el" href="classwx_window.html#cdc11d78f715add007eec76b608eaa58">wxWindow::RegisterHotKey()</a>, and unregister the button when you're done with it. For example:<p>
<div class="fragment"><pre class="fragment">win-&gt;RegisterHotKey(0, wxMOD_WIN, WXK_SPECIAL1);
win-&gt;UnregisterHotKey(0);
</pre></div><p>
You may have to register the buttons in a <code>wxEVT_ACTIVATE</code> event handler since other applications will grab the buttons.<p>
There is currently no method of finding out the names of the special buttons or how many there are.<h4><a class="anchor" name="page_port_wxmsw_wince_dialogs">
Dialogs in wxWinCE</a></h4>
PocketPC dialogs have an OK button on the caption, and so you should generally not repeat an OK button on the dialog. You can add a Cancel button if necessary, but some dialogs simply don't offer you the choice (the guidelines recommend you offer an Undo facility to make up for it). When the user clicks on the OK button, your dialog will receive a <code>wxID_OK</code> event by default. If you wish to change this, call <a class="el" href="classwx_dialog.html#72ea7e269bedb2552bfeaccdbac07939">wxDialog::SetAffirmativeId()</a> with the required identifier to be used. Or, override <a class="el" href="classwx_dialog.html#08a07820be45f6c6fcde5c9e2f786389">wxDialog::DoOK()</a> (return <span class="literal">false</span> to have wxWidgets simply call Close to dismiss the dialog).<p>
Smartphone dialogs do <em>not</em> have an OK button on the caption, and are closed using one of the two menu buttons. You need to assign these using <a class="el" href="classwx_top_level_window.html#198cff4212ff5342c0c4358b59274fd5">wxTopLevelWindow::SetLeftMenu</a> and <a class="el" href="classwx_top_level_window.html#98e95b1b10f44b80f9b29a03ab09a879">wxTopLevelWindow::SetRightMenu()</a>, for example:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifdef __SMARTPHONE__</span>
<span class="preprocessor"></span>    SetLeftMenu(wxID_OK);
    SetRightMenu(wxID_CANCEL, <a class="code" href="group__group__funcmacro__string.html#g1d15d85659f941b7fa02fafc6010b348">_</a>(<span class="stringliteral">"Cancel"</span>));
<span class="preprocessor">#elif defined(__POCKETPC__)</span>
<span class="preprocessor"></span>    <span class="comment">// No OK/Cancel buttons on PocketPC, OK on caption will close</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    topsizer-&gt;Add( CreateButtonSizer( wxOK|wxCANCEL ), 0, wxEXPAND | wxALL, 10 );
<span class="preprocessor">#endif</span>
</pre></div><p>
For implementing property sheets (flat tabs), use a <a class="el" href="classwx_notebook.html">wxNotebook</a> with <code>wxNB_FLAT|wxNB_BOTTOM</code> and have the notebook left, top and right sides overlap the dialog by about 3 pixels to eliminate spurious borders. You can do this by using a negative spacing in your sizer Add() call. The cross-platform property sheet dialog <a class="el" href="classwx_property_sheet_dialog.html">wxPropertySheetDialog</a> is provided, to show settings in the correct style on PocketPC and on other platforms.<p>
Notifications (bubble HTML text with optional buttons and links) will also be implemented in the future for PocketPC.<p>
Modeless dialogs probably don't make sense for PocketPC and Smartphone, since frames and dialogs are normally full-screen, and a modeless dialog is normally intended to co-exist with the main application frame.<h4><a class="anchor" name="page_port_wxmsw_wince_ppc">
Menubars and toolbars in PocketPC</a></h4>
On PocketPC, a frame must always have a menubar, even if it's empty. An empty menubar/toolbar is automatically provided for dialogs, to hide any existing menubar for the duration of the dialog.<p>
Menubars and toolbars are implemented using a combined control, but you can use essentially the usual wxWidgets API; wxWidgets will combine the menubar and toolbar. However, there are some restrictions:<p>
<ul>
<li>You must create the frame's primary toolbar with <a class="el" href="classwx_frame.html#087f82c37f92d1c86fd54611933169c0">wxFrame::CreateToolBar()</a>, because this uses the special wxToolMenuBar class (derived from <a class="el" href="classwx_tool_bar.html">wxToolBar</a>) to implement the combined toolbar and menubar. Otherwise, you can create and manage toolbars using the <a class="el" href="classwx_tool_bar.html">wxToolBar</a> class as usual, for example to implement an optional formatting toolbar above the menubar as Pocket Word does. But don't assign a <a class="el" href="classwx_tool_bar.html">wxToolBar</a> to a frame using SetToolBar - you should always use CreateToolBar for the main frame toolbar. </li>
<li>Deleting and adding tools to wxToolMenuBar after Realize is called is not supported. </li>
<li>For speed, colours are not remapped to the system colours as they are in wxMSW. Provide the tool bitmaps either with the correct system button background, or with transparency (for example, using XPMs). </li>
<li>Adding controls to wxToolMenuBar is not supported. However, <a class="el" href="classwx_tool_bar.html">wxToolBar</a> supports controls.</li>
</ul>
Unlike in all other ports, a <a class="el" href="classwx_dialog.html">wxDialog</a> has a <a class="el" href="classwx_tool_bar.html">wxToolBar</a>, automatically created for you. You may either leave it blank, or access it with <a class="el" href="classwx_dialog.html#80c76ed6b8f6eb92992f816e1a987f80">wxDialog::GetToolBar()</a> and add buttons, then calling <a class="el" href="classwx_tool_bar.html#237d73c6a2fc196da82a943ec8f3f381">wxToolBar::Realize()</a>. You cannot set or recreate the toolbar.<h4><a class="anchor" name="page_port_wxmsw_wince_smart">
Menubars and toolbars in Smartphone</a></h4>
On Smartphone, there are only two menu buttons, so a menubar is simulated using a nested menu on the right menu button. Any toolbars are simply ignored on Smartphone.<h4><a class="anchor" name="page_port_wxmsw_wince_closing">
Closing windows in wxWinCE</a></h4>
The guidelines state that applications should not have a Quit menu item, since the user should not have to know whether an application is in memory or not. The close button on a window does not call the window's close handler; it simply hides the window. However, the guidelines say that the Ctrl+Q accelerator can be used to quit the application, so wxWidgets defines this accelerator by default and if your application handles wxID_EXIT, it will do the right thing.<h4><a class="anchor" name="page_port_wxmsw_wince_ctx">
Context menus in wxWinCE</a></h4>
To enable context menus in PocketPC, you currently need to call wxWindow::EnableContextMenu(), a wxWinCE-only function. Otherwise the context menu event (<a class="el" href="classwx_context_menu_event.html">wxContextMenuEvent</a>) will never be sent. This API is subject to change.<p>
Context menus are not supported in Smartphone.<h4><a class="anchor" name="page_port_wxmsw_wince_ctrl">
Control differences on wxWinCE</a></h4>
These controls and styles are specific to wxWinCE:<p>
<ul>
<li><a class="el" href="classwx_text_ctrl.html">wxTextCtrl</a> The <code>wxTE_CAPITALIZE</code> style causes a CAPEDIT control to be created, which capitalizes the first letter.</li>
</ul>
These controls are missing from wxWinCE:<p>
<ul>
<li>MDI classes MDI is not supported under Windows CE. </li>
<li><a class="el" href="classwx_mini_frame.html">wxMiniFrame</a> Not supported under Windows CE.</li>
</ul>
Tooltips are not currently supported for controls, since on PocketPC controls with tooltips are distinct controls, and it will be hard to add dynamic tooltip support.<p>
Control borders on PocketPC and Smartphone should normally be specified with <code>wxBORDER_SIMPLE</code> instead of <code>wxBORDER_SUNKEN</code>. Controls will usually adapt appropriately by virtue of their GetDefaultBorder() function, but if you wish to specify a style explicitly you can use <code>wxDEFAULT_CONTROL_BORDER</code> which will give a simple border on PocketPC and Smartphone, and the sunken border on other platforms.<h4><a class="anchor" name="page_port_wxmsw_wince_help">
Online help in wxWinCE</a></h4>
You can use the help controller wxWinceHelpController which controls simple <code></code>.htm files, usually installed in the Windows directory. See the Windows CE reference for how to format the HTML files.<h4><a class="anchor" name="page_port_wxmsw_wince_install">
Installing your PocketPC and Smartphone applications</a></h4>
To install your application, you need to build a CAB file using the parameters defined in a special .inf file. The CabWiz program in your SDK will compile the CAB file from the .inf file and files that it specifies.<p>
For delivery, you can simply ask the user to copy the CAB file to the device and execute the CAB file using File Explorer. Or, you can write a program for the desktop PC that will find the ActiveSync Application Manager and install the CAB file on the device, which is obviously much easier for the user.<p>
Here are some links that may help.<p>
<ul>
<li>A setup builder that takes CABs and builds a setup program is at <a href="http://www.eskimo.com/~scottlu/win/index.html.">http://www.eskimo.com/~scottlu/win/index.html.</a> </li>
<li>Sample installation files can be found in <code>Windows CE Tools/wce420/POCKET PC 2003/Samples/Win32/AppInst</code>. </li>
<li>An installer generator using wxPython can be found at <a href="http://ppcquicksoft.iespana.es/ppcquicksoft/myinstall.html.">http://ppcquicksoft.iespana.es/ppcquicksoft/myinstall.html.</a> </li>
<li>Miscellaneous Windows CE resources can be found at <a href="http://www.orbworks.com/pcce/resources.html.">http://www.orbworks.com/pcce/resources.html.</a> </li>
<li>Installer creation instructions with a setup.exe for installing to PPC can be found at <a href="http://www.pocketpcdn.com/articles/creatingsetup.html.">http://www.pocketpcdn.com/articles/creatingsetup.html.</a> </li>
<li>Microsoft instructions are at <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnce30/html/appinstall30.asp?frame=true">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnce30/html/appinstall30.asp?frame=true</a> </li>
<li>Troubleshooting WinCE application installations: <a href="http://support.microsoft.com/default.aspx?scid=KB;en-us;q181007">http://support.microsoft.com/default.aspx?scid=KB;en-us;q181007</a></li>
</ul>
You may also check out <code>demos/life/setup/wince</code> which contains scripts to create a PocketPC installation for ARM-based devices. In particular, <code>build.bat</code> builds the distribution and copies it to a directory called <code>Deliver</code>.<h4><a class="anchor" name="page_port_wxmsw_wince_filedlg">
wxFileDialog in PocketPC</a></h4>
Allowing the user to access files on memory cards, or on arbitrary parts of the filesystem, is a pain; the standard file dialog only shows folders under My Documents or folders on memory cards (not the system or card root directory, for example). This is a known problem for PocketPC developers.<p>
If you need a file dialog that allows access to all folders, you can use wxGenericFileDialog instead. You will need to include <code>wx/generic/filedlgg.h</code>.<h4><a class="anchor" name="page_port_wxmsw_wince_evc">
Embedded Visual C++ Issues</a></h4>
<b>Run-time type information</b><p>
If you wish to use runtime type information (RTTI) with eVC++ 4, you need to download an extra library, <code>ccrtrtti.lib</code>, and link with it. At the time of writing you can get it from here:<p>
<div class="fragment"><pre class="fragment">
http://support.microsoft.com/kb/830482/en-us
</pre></div><p>
Otherwise you will get linker errors similar to this:<p>
<div class="fragment"><pre class="fragment">
wxwince26d.lib(control.obj) : error LNK2001: unresolved external symbol "const type_info::`vftable'" (??_7type_info@@6B@)
</pre></div><p>
<b>Windows Mobile 5.0 emulator</b><p>
Note that there is no separate emulator configuration for Windows Mobile 5.0: the emulator runs the ARM code directly.<p>
<b>Visual Studio 2005 project files</b><p>
Unfortunately, Visual Studio 2005, required to build Windows Mobile 5.0 applications, doesn't do a perfect job of converting the project files from eVC++ format.<p>
When you have converted the wxWidgets workspace, edit the configuration properties for each configuration and in the Librarian, add a relative path ..\..\lib to each library path. For example: <code>..\\\wx_mono.lib</code>.<p>
Then, for a sample you want to compile, edit the configuration properties and make sure <code>..\..\lib\\</code> is in the Linker/General/Additional Library Directories property. Also change the Linker/Input/Additional Dependencies property to something like <code>coredll.lib wx_mono.lib wx_wxjpeg.lib wx_wxpng.lib wx_wxzlib.lib wx_wxexpat.lib commctrl.lib winsock.lib wininet.lib</code> (since the library names in the wxWidgets workspace were changed by VS 2005).<p>
Alternately, you could could edit all the names to be identical to the original eVC++ names, but this will probably be more fiddly.<h4><a class="anchor" name="page_port_wxmsw_wince_issues">
Remaining issues</a></h4>
These are some of the remaining problems to be sorted out, and features to be supported.<p>
<ul>
<li><b>Windows Mobile 5 issues.</b> It is not possible to get the HMENU for the command bar on Mobile 5, so the menubar functions need to be rewritten to get the individual menus without use of a menubar handle. Also the new Mobile 5 convention of using only two menus (and no bitmap buttons) needs to be considered. </li>
<li><b>Sizer speed.</b> Particularly for dialogs containing notebooks, layout seems slow. Some analysis is required. </li>
<li><b>Notification boxes.</b> The balloon-like notification messages, and their icons, should be implemented. This will be quite straightforward. </li>
<li><b>SIP size.</b> We need to be able to get the area taken up by the SIP (input panel), and the remaining area, by calling SHSipInfo. We also may need to be able to show and hide the SIP programmatically, with SHSipPreference. See also the <em>Input Dialogs</em> topic in the <em>Programming Windows CE</em> guide for more on this, and how to have dialogs show the SIP automatically using the <code>WC_SIPREF</code> control. </li>
<li><b><a class="el" href="classwx_static_bitmap.html">wxStaticBitmap</a>.</b> The About box in the "Life!" demo shows a bitmap that is the correct size on the emulator, but too small on a VGA Pocket Loox device. </li>
<li><b><a class="el" href="classwx_static_line.html">wxStaticLine</a>.</b> Lines don't show up, and the documentation suggests that missing styles are implemented with <code>WM_PAINT</code>. </li>
<li><b>HTML control.</b> PocketPC has its own HTML control which can be used for showing local pages or navigating the web. We should create a version of <a class="el" href="classwx_html_window.html">wxHtmlWindow</a> that uses this control, or have a separately-named control (wxHtmlCtrl), with a syntax as close as possible to <a class="el" href="classwx_html_window.html">wxHtmlWindow</a>. </li>
<li><b>Tooltip control.</b> PocketPC uses special TTBUTTON and TTSTATIC controls for adding tooltips, with the tooltip separated from the label with a double tilde. We need to support this using SetToolTip.(Unfortunately it does not seem possible to dynamically remove the tooltip, so an extra style may be required.) </li>
<li><b>Focus.</b> In the <a class="el" href="classwx_property_sheet_dialog.html">wxPropertySheetDialog</a> demo on Smartphone, it's not possible to navigate between controls. The focus handling in wxWidgets needs investigation. See in particular src/common/containr.cpp, and note that the default OnActivate handler in src/msw/toplevel.cpp sets the focus to the first child of the dialog. </li>
<li><b>OK button.</b> We should allow the OK button on a dialog to be optional, perhaps by using <code>wxCLOSE_BOX</code> to indicate when the OK button should be displayed. </li>
<li><b>Dynamic adaptation.</b> We should probably be using run-time tests more than preprocessor tests, so that the same WinCE application can run on different versions of the operating system. </li>
<li><b>Modeless dialogs.</b> When a modeless dialog is hidden with the OK button, it doesn't restore the frame's menubar. See for example the find dialog in the dialogs sample. However, the menubar is restored if pressing Cancel (the window is closed). This reflects the fact that modeless dialogs are not very useful on Windows CE; however, we could perhaps destroy/restore a modeless dialog's menubar on deactivation and activation. </li>
<li><b>Home screen plugins.</b> Figure out how to make home screen plugins for use with wxWidgets applications (see <a href="http://www.codeproject.com/ce/CTodayWindow.asp">http://www.codeproject.com/ce/CTodayWindow.asp</a> for inspiration). Although we can't use wxWidgets to create the plugin (too large), we could perhaps write a generic plugin that takes registry information from a given application, with options to display information in a particular way using icons and text from a specified location. </li>
<li><b>Further abstraction.</b> We should be able to abstract away more of the differences between desktop and mobile applications, in particular for sizer layout. </li>
<li><b>Dialog captions.</b> The blue, bold captions on dialogs - with optional help button - should be catered for, either by hard-wiring the capability into all dialogs and panels, or by providing a standard component and sizer.</li>
</ul>
<h2><a class="anchor" name="page_port_nativedocs">
Documentation for the native toolkits</a></h2>
It's sometimes useful to interface directly with the underlying toolkit used by wxWidgets to e.g. use toolkit-specific features. In such case (or when you want to e.g. write a port-specific patch) it can be necessary to use the underlying toolkit API directly:<p>
<ul>
<li>wxMSW port uses win32 API: see MSDN docs at <a href="http://msdn2.microsoft.com/en-us/library/ms649779.aspx">http://msdn2.microsoft.com/en-us/library/ms649779.aspx</a> </li>
<li>wxGTK port uses GTK+: see GTK+ 2.x docs at <a href="http://developer.gnome.org/doc/API/2.0/gtk/index.html">http://developer.gnome.org/doc/API/2.0/gtk/index.html</a> </li>
<li>wxMac port uses the Carbon API: see Carbon docs at <a href="http://developer.apple.com/carbon">http://developer.apple.com/carbon</a> </li>
<li>wxCocoa port uses the Cocoa API: see Cocoa docs at <a href="http://developer.apple.com/carbon">http://developer.apple.com/carbon</a> </li>
</ul>
</div>
<!-- ******************************************************* -->
<!--             Standard wxWidgets footer                   -->

<!-- NOTE: <br/> must go inside <p> but <hr/> must go outside -->
<p><br/></p><hr/>

<table width="100%" border="0">
<tr>
    <td align="left">
        <a href="http://www.wxwidgets.org/" style="margin-left: 0px">
            <img src="powered-by-wxwidgets.png" alt="wxWidgets logo" border="0"/>
        </a>
    </td>
    <td valign="middle" align="center"><p class="footer">Page generated <tt>Sat Sep 6 08:15:37 2008</tt> by <a href="http://www.doxygen.org/">Doxygen</a> 1.5.6</p></td>
    <td valign="middle" align="right"><p>[ <a href="wsdindex.html#top" class="top">top</a> ]</p></td>
</tr>
</table>

<script src="wxwidgets.js" type="text/javascript"></script>

<script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
    var pageTracker = _gat._getTracker("UA-794025-2");
    pageTracker._initData();
    pageTracker._trackPageview();
</script>

</body>
</html>

<!-- ***************************************************** -->
<!--         End of wxWidgets standard footer              -->
